<?xml version='1.0' encoding='UTF-8' standalone='no'?>
<section xmlns="http://docbook.org/ns/docbook" version="5.0" xmlns:xlink="http://www.w3.org/1999/xlink" xml:id="__audio_file_8h_source" xml:lang="en-US">
<title>AudioFile.h</title>
<indexterm><primary>AudioFile/AudioFile.h</primary></indexterm>
Go to the documentation of this file.<programlisting linenumbering="unnumbered">1 <emphasis role="comment">//=======================================================================</emphasis>
21 <emphasis role="comment"></emphasis><emphasis role="comment">//=======================================================================</emphasis>
22 
23 <emphasis role="preprocessor">#ifndef&#32;_AS_AudioFile_h</emphasis>
24 <emphasis role="preprocessor">#define&#32;_AS_AudioFile_h</emphasis>
25 
26 <emphasis role="preprocessor">#include&#32;&lt;iostream&gt;</emphasis>
27 <emphasis role="preprocessor">#include&#32;&lt;vector&gt;</emphasis>
28 <emphasis role="preprocessor">#include&#32;&lt;cassert&gt;</emphasis>
29 <emphasis role="preprocessor">#include&#32;&lt;string&gt;</emphasis>
30 <emphasis role="preprocessor">#include&#32;&lt;cstring&gt;</emphasis>
31 <emphasis role="preprocessor">#include&#32;&lt;fstream&gt;</emphasis>
32 <emphasis role="preprocessor">#include&#32;&lt;unordered_map&gt;</emphasis>
33 <emphasis role="preprocessor">#include&#32;&lt;iterator&gt;</emphasis>
34 <emphasis role="preprocessor">#include&#32;&lt;algorithm&gt;</emphasis>
35 
36 <emphasis role="comment">//&#32;disable&#32;some&#32;warnings&#32;on&#32;Windows</emphasis>
37 <emphasis role="preprocessor">#if&#32;defined&#32;(_MSC_VER)</emphasis>
38 &#32;&#32;&#32;&#32;__pragma(warning&#32;(push))
39 &#32;&#32;&#32;&#32;__pragma(warning&#32;(disable&#32;:&#32;4244))
40 &#32;&#32;&#32;&#32;__pragma(warning&#32;(disable&#32;:&#32;4457))
41 &#32;&#32;&#32;&#32;__pragma(warning&#32;(disable&#32;:&#32;4458))
42 &#32;&#32;&#32;&#32;__pragma(warning&#32;(disable&#32;:&#32;4389))
43 &#32;&#32;&#32;&#32;__pragma(warning&#32;(disable&#32;:&#32;4996))
44 <emphasis role="preprocessor">#elif&#32;defined&#32;(__GNUC__)</emphasis>
45 &#32;&#32;&#32;&#32;_Pragma(<emphasis role="stringliteral">&quot;GCC&#32;diagnostic&#32;push&quot;</emphasis>)
46 &#32;&#32;&#32;&#32;_Pragma(&quot;GCC&#32;diagnostic&#32;ignored&#32;\&quot;-Wconversion\&quot;&quot;)
47 &#32;&#32;&#32;&#32;_Pragma(&quot;GCC&#32;diagnostic&#32;ignored&#32;\&quot;-Wsign-compare\&quot;&quot;)
48 &#32;&#32;&#32;&#32;_Pragma(&quot;GCC&#32;diagnostic&#32;ignored&#32;\&quot;-Wshadow\&quot;&quot;)
49 <emphasis role="preprocessor">#endif</emphasis>
50 
51 <emphasis role="comment">//=============================================================</emphasis>
56 <emphasis role="comment"></emphasis><emphasis role="keyword">enum&#32;class</emphasis>&#32;<link linkend="__audio_file_8h_1ad18559d169602e85d0ad68da6ef8593f">AudioFileFormat</link>
57 {
58 &#32;&#32;&#32;&#32;<link linkend="__audio_file_8h_1a526ed66f20752002a63ee72e2e350d7da4dfd42ec49d09d8c6555c218301cc30f">Error</link>,
59 &#32;&#32;&#32;&#32;<link linkend="__audio_file_8h_1ad18559d169602e85d0ad68da6ef8593fa5111e24c1ecc6266ce0de4b4dc42033b">NotLoaded</link>,
60 &#32;&#32;&#32;&#32;<link linkend="__audio_file_8h_1ad18559d169602e85d0ad68da6ef8593fad911b34823c7674c292556dc56148c27">Wave</link>,
61 &#32;&#32;&#32;&#32;<link linkend="__audio_file_8h_1ad18559d169602e85d0ad68da6ef8593fac2271ab764905d770a81d0920f8c6aaf">Aiff</link>
62 };
63 
64 <emphasis role="comment">//=============================================================</emphasis>
65 <emphasis role="keyword">template</emphasis>&#32;&lt;<emphasis role="keyword">class</emphasis>&#32;T&gt;
66 <emphasis role="keyword">class&#32;</emphasis><link linkend="_class_audio_file">AudioFile</link>
67 {
68 <emphasis role="keyword">public</emphasis>:
69 &#32;&#32;&#32;&#32;
70 &#32;&#32;&#32;&#32;<emphasis role="comment">//=============================================================</emphasis>
71 &#32;&#32;&#32;&#32;<emphasis role="keyword">typedef</emphasis>&#32;std::vector&lt;std::vector&lt;T&gt;&#32;&gt;&#32;<link linkend="_class_audio_file_1ad1260a47791dc30cbabfe3ff2ea099b1">AudioBuffer</link>;
72 &#32;&#32;&#32;&#32;
73 &#32;&#32;&#32;&#32;<emphasis role="comment">//=============================================================</emphasis>
75 <emphasis role="comment"></emphasis>&#32;&#32;&#32;&#32;<link linkend="_class_audio_file_1ae74399e93d3f4623c7421ee10cfc0e15">AudioFile</link>();
76 &#32;&#32;&#32;&#32;
78 &#32;&#32;&#32;&#32;<link linkend="_class_audio_file_1ae74399e93d3f4623c7421ee10cfc0e15">AudioFile</link>&#32;(std::string&#32;filePath);
79 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;
80 &#32;&#32;&#32;&#32;<emphasis role="comment">//=============================================================</emphasis>
84 <emphasis role="comment"></emphasis>&#32;&#32;&#32;&#32;<emphasis role="keywordtype">bool</emphasis>&#32;<link linkend="_class_audio_file_1a0ff16123b519a4665e9f3e7d341f0a26">load</link>&#32;(std::string&#32;filePath);
85 &#32;&#32;&#32;&#32;
89 &#32;&#32;&#32;&#32;<emphasis role="keywordtype">bool</emphasis>&#32;<link linkend="_class_audio_file_1a415239cad5b54b4fef4a210ab79911e3">save</link>&#32;(std::string&#32;filePath,&#32;<link linkend="__audio_file_8h_1ad18559d169602e85d0ad68da6ef8593f">AudioFileFormat</link>&#32;format&#32;=&#32;<link linkend="__audio_file_8h_1ad18559d169602e85d0ad68da6ef8593fad911b34823c7674c292556dc56148c27">AudioFileFormat::Wave</link>);
90 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;
91 &#32;&#32;&#32;&#32;<emphasis role="comment">//=============================================================</emphasis>
93 <emphasis role="comment"></emphasis>&#32;&#32;&#32;&#32;uint32_t&#32;<link linkend="_class_audio_file_1a8cd1b082af9db6bd180e4a63edcdefc9">getSampleRate</link>()&#32;<emphasis role="keyword">const</emphasis>;
94 &#32;&#32;&#32;&#32;
96 &#32;&#32;&#32;&#32;<emphasis role="keywordtype">int</emphasis>&#32;<link linkend="_class_audio_file_1a514f860a956b4494ee8d8c806391d6b3">getNumChannels</link>()&#32;<emphasis role="keyword">const</emphasis>;
97 
99 &#32;&#32;&#32;&#32;<emphasis role="keywordtype">bool</emphasis>&#32;<link linkend="_class_audio_file_1a1057326fd2c2eca7cc7937f811868cf1">isMono</link>()&#32;<emphasis role="keyword">const</emphasis>;
100 &#32;&#32;&#32;&#32;
102 &#32;&#32;&#32;&#32;<emphasis role="keywordtype">bool</emphasis>&#32;<link linkend="_class_audio_file_1a380a188d95f8f23b7622dfe222a7e8f6">isStereo</link>()&#32;<emphasis role="keyword">const</emphasis>;
103 &#32;&#32;&#32;&#32;
105 &#32;&#32;&#32;&#32;<emphasis role="keywordtype">int</emphasis>&#32;<link linkend="_class_audio_file_1a5495d5cb55911de54f0714e219130b48">getBitDepth</link>()&#32;<emphasis role="keyword">const</emphasis>;
106 &#32;&#32;&#32;&#32;
108 &#32;&#32;&#32;&#32;<emphasis role="keywordtype">int</emphasis>&#32;<link linkend="_class_audio_file_1ae1b5b4b7351a79dbf810bb34ede496b9">getNumSamplesPerChannel</link>()&#32;<emphasis role="keyword">const</emphasis>;
109 &#32;&#32;&#32;&#32;
111 &#32;&#32;&#32;&#32;<emphasis role="keywordtype">double</emphasis>&#32;<link linkend="_class_audio_file_1a5a6b01404675361b1c21c9c5fb5753d4">getLengthInSeconds</link>()&#32;<emphasis role="keyword">const</emphasis>;
112 &#32;&#32;&#32;&#32;
114 &#32;&#32;&#32;&#32;<emphasis role="keywordtype">void</emphasis>&#32;<link linkend="_class_audio_file_1a7b88c68133a9ac92149c58499e026360">printSummary</link>()&#32;<emphasis role="keyword">const</emphasis>;
115 &#32;&#32;&#32;&#32;
116 &#32;&#32;&#32;&#32;<emphasis role="comment">//=============================================================</emphasis>
117 &#32;&#32;&#32;&#32;
121 &#32;&#32;&#32;&#32;<emphasis role="keywordtype">bool</emphasis>&#32;<link linkend="_class_audio_file_1afa0a0f7d576b0597c938c5a89746636e">setAudioBuffer</link>&#32;(<link linkend="_class_audio_file_1ad1260a47791dc30cbabfe3ff2ea099b1">AudioBuffer</link>&amp;&#32;newBuffer);
122 &#32;&#32;&#32;&#32;
126 &#32;&#32;&#32;&#32;<emphasis role="keywordtype">void</emphasis>&#32;<link linkend="_class_audio_file_1ac155ed12db0f3b02011a7d75b525e71a">setAudioBufferSize</link>&#32;(<emphasis role="keywordtype">int</emphasis>&#32;<link linkend="_namespacemake_headers_1aebae91248540ba01faf787f19070a220">numChannels</link>,&#32;<emphasis role="keywordtype">int</emphasis>&#32;numSamples);
127 &#32;&#32;&#32;&#32;
131 &#32;&#32;&#32;&#32;<emphasis role="keywordtype">void</emphasis>&#32;<link linkend="_class_audio_file_1a4cff9513d49e21d25de13513564784b7">setNumSamplesPerChannel</link>&#32;(<emphasis role="keywordtype">int</emphasis>&#32;numSamples);
132 &#32;&#32;&#32;&#32;
134 &#32;&#32;&#32;&#32;<emphasis role="keywordtype">void</emphasis>&#32;<link linkend="_class_audio_file_1a354018a94ae15907d7308782f2adadbb">setNumChannels</link>&#32;(<emphasis role="keywordtype">int</emphasis>&#32;<link linkend="_namespacemake_headers_1aebae91248540ba01faf787f19070a220">numChannels</link>);
135 &#32;&#32;&#32;&#32;
137 &#32;&#32;&#32;&#32;<emphasis role="keywordtype">void</emphasis>&#32;<link linkend="_class_audio_file_1a2adf2ea23e7daeb8401e717c1b3d874b">setBitDepth</link>&#32;(<emphasis role="keywordtype">int</emphasis>&#32;numBitsPerSample);
138 &#32;&#32;&#32;&#32;
140 &#32;&#32;&#32;&#32;<emphasis role="keywordtype">void</emphasis>&#32;<link linkend="_class_audio_file_1a2d8fa306e40535113c3eba111e16483b">setSampleRate</link>&#32;(uint32_t&#32;newSampleRate);
141 &#32;&#32;&#32;&#32;
142 &#32;&#32;&#32;&#32;<emphasis role="comment">//=============================================================</emphasis>
144 <emphasis role="comment"></emphasis>&#32;&#32;&#32;&#32;<emphasis role="keywordtype">void</emphasis>&#32;<link linkend="_class_audio_file_1a1986c0297e4e4db99435702528e9c3c4">shouldLogErrorsToConsole</link>&#32;(<emphasis role="keywordtype">bool</emphasis>&#32;logErrors);
145 &#32;&#32;&#32;&#32;
146 &#32;&#32;&#32;&#32;<emphasis role="comment">//=============================================================</emphasis>
152 <emphasis role="comment"></emphasis>&#32;&#32;&#32;&#32;<link linkend="_class_audio_file_1ad1260a47791dc30cbabfe3ff2ea099b1">AudioBuffer</link>&#32;<link linkend="_class_audio_file_1af937119db095c5af870851050dcbeabb">samples</link>;
153 &#32;&#32;&#32;&#32;
154 &#32;&#32;&#32;&#32;<emphasis role="comment">//=============================================================</emphasis>
157 <emphasis role="comment"></emphasis>&#32;&#32;&#32;&#32;std::string&#32;<link linkend="_class_audio_file_1ab2bc14440b0a6ff1a297e28a0354d422">iXMLChunk</link>;
158 &#32;&#32;&#32;&#32;
159 <emphasis role="keyword">private</emphasis>:
160 &#32;&#32;&#32;&#32;
161 &#32;&#32;&#32;&#32;<emphasis role="comment">//=============================================================</emphasis>
162 &#32;&#32;&#32;&#32;<emphasis role="keyword">enum&#32;class</emphasis>&#32;Endianness
163 &#32;&#32;&#32;&#32;{
164 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;LittleEndian,
165 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;BigEndian
166 &#32;&#32;&#32;&#32;};
167 &#32;&#32;&#32;&#32;
168 &#32;&#32;&#32;&#32;<emphasis role="comment">//=============================================================</emphasis>
169 &#32;&#32;&#32;&#32;<link linkend="__audio_file_8h_1ad18559d169602e85d0ad68da6ef8593f">AudioFileFormat</link>&#32;determineAudioFileFormat&#32;(std::vector&lt;uint8_t&gt;&amp;&#32;fileData);
170 &#32;&#32;&#32;&#32;<emphasis role="keywordtype">bool</emphasis>&#32;decodeWaveFile&#32;(std::vector&lt;uint8_t&gt;&amp;&#32;fileData);
171 &#32;&#32;&#32;&#32;<emphasis role="keywordtype">bool</emphasis>&#32;decodeAiffFile&#32;(std::vector&lt;uint8_t&gt;&amp;&#32;fileData);
172 &#32;&#32;&#32;&#32;
173 &#32;&#32;&#32;&#32;<emphasis role="comment">//=============================================================</emphasis>
174 &#32;&#32;&#32;&#32;<emphasis role="keywordtype">bool</emphasis>&#32;saveToWaveFile&#32;(std::string&#32;filePath);
175 &#32;&#32;&#32;&#32;<emphasis role="keywordtype">bool</emphasis>&#32;saveToAiffFile&#32;(std::string&#32;filePath);
176 &#32;&#32;&#32;&#32;
177 &#32;&#32;&#32;&#32;<emphasis role="comment">//=============================================================</emphasis>
178 &#32;&#32;&#32;&#32;<emphasis role="keywordtype">void</emphasis>&#32;clearAudioBuffer();
179 &#32;&#32;&#32;&#32;
180 &#32;&#32;&#32;&#32;<emphasis role="comment">//=============================================================</emphasis>
181 &#32;&#32;&#32;&#32;int32_t&#32;fourBytesToInt&#32;(std::vector&lt;uint8_t&gt;&amp;&#32;source,&#32;<emphasis role="keywordtype">int</emphasis>&#32;startIndex,&#32;Endianness&#32;endianness&#32;=&#32;Endianness::LittleEndian);
182 &#32;&#32;&#32;&#32;int16_t&#32;twoBytesToInt&#32;(std::vector&lt;uint8_t&gt;&amp;&#32;source,&#32;<emphasis role="keywordtype">int</emphasis>&#32;startIndex,&#32;Endianness&#32;endianness&#32;=&#32;Endianness::LittleEndian);
183 &#32;&#32;&#32;&#32;<emphasis role="keywordtype">int</emphasis>&#32;getIndexOfString&#32;(std::vector&lt;uint8_t&gt;&amp;&#32;source,&#32;std::string&#32;s);
184 &#32;&#32;&#32;&#32;<emphasis role="keywordtype">int</emphasis>&#32;getIndexOfChunk&#32;(std::vector&lt;uint8_t&gt;&amp;&#32;source,&#32;<emphasis role="keyword">const</emphasis>&#32;std::string&amp;&#32;chunkHeaderID,&#32;<emphasis role="keywordtype">int</emphasis>&#32;startIndex,&#32;Endianness&#32;endianness&#32;=&#32;Endianness::LittleEndian);
185 &#32;&#32;&#32;&#32;
186 &#32;&#32;&#32;&#32;<emphasis role="comment">//=============================================================</emphasis>
187 &#32;&#32;&#32;&#32;T&#32;sixteenBitIntToSample&#32;(int16_t&#32;sample);
188 &#32;&#32;&#32;&#32;int16_t&#32;sampleToSixteenBitInt&#32;(T&#32;sample);
189 &#32;&#32;&#32;&#32;
190 &#32;&#32;&#32;&#32;<emphasis role="comment">//=============================================================</emphasis>
191 &#32;&#32;&#32;&#32;uint8_t&#32;sampleToSingleByte&#32;(T&#32;sample);
192 &#32;&#32;&#32;&#32;T&#32;singleByteToSample&#32;(uint8_t&#32;sample);
193 &#32;&#32;&#32;&#32;
194 &#32;&#32;&#32;&#32;uint32_t&#32;getAiffSampleRate&#32;(std::vector&lt;uint8_t&gt;&amp;&#32;fileData,&#32;<emphasis role="keywordtype">int</emphasis>&#32;sampleRateStartIndex);
195 &#32;&#32;&#32;&#32;<emphasis role="keywordtype">bool</emphasis>&#32;tenByteMatch&#32;(std::vector&lt;uint8_t&gt;&amp;&#32;v1,&#32;<emphasis role="keywordtype">int</emphasis>&#32;startIndex1,&#32;std::vector&lt;uint8_t&gt;&amp;&#32;v2,&#32;<emphasis role="keywordtype">int</emphasis>&#32;startIndex2);
196 &#32;&#32;&#32;&#32;<emphasis role="keywordtype">void</emphasis>&#32;addSampleRateToAiffData&#32;(std::vector&lt;uint8_t&gt;&amp;&#32;fileData,&#32;uint32_t&#32;sampleRate);
197 &#32;&#32;&#32;&#32;T&#32;clamp&#32;(T&#32;v1,&#32;T&#32;minValue,&#32;T&#32;maxValue);
198 &#32;&#32;&#32;&#32;
199 &#32;&#32;&#32;&#32;<emphasis role="comment">//=============================================================</emphasis>
200 &#32;&#32;&#32;&#32;<emphasis role="keywordtype">void</emphasis>&#32;addStringToFileData&#32;(std::vector&lt;uint8_t&gt;&amp;&#32;fileData,&#32;std::string&#32;s);
201 &#32;&#32;&#32;&#32;<emphasis role="keywordtype">void</emphasis>&#32;addInt32ToFileData&#32;(std::vector&lt;uint8_t&gt;&amp;&#32;fileData,&#32;int32_t&#32;i,&#32;Endianness&#32;endianness&#32;=&#32;Endianness::LittleEndian);
202 &#32;&#32;&#32;&#32;<emphasis role="keywordtype">void</emphasis>&#32;addInt16ToFileData&#32;(std::vector&lt;uint8_t&gt;&amp;&#32;fileData,&#32;int16_t&#32;i,&#32;Endianness&#32;endianness&#32;=&#32;Endianness::LittleEndian);
203 &#32;&#32;&#32;&#32;
204 &#32;&#32;&#32;&#32;<emphasis role="comment">//=============================================================</emphasis>
205 &#32;&#32;&#32;&#32;<emphasis role="keywordtype">bool</emphasis>&#32;writeDataToFile&#32;(std::vector&lt;uint8_t&gt;&amp;&#32;fileData,&#32;std::string&#32;filePath);
206 &#32;&#32;&#32;&#32;
207 &#32;&#32;&#32;&#32;<emphasis role="comment">//=============================================================</emphasis>
208 &#32;&#32;&#32;&#32;<emphasis role="keywordtype">void</emphasis>&#32;reportError&#32;(std::string&#32;errorMessage);
209 &#32;&#32;&#32;&#32;
210 &#32;&#32;&#32;&#32;<emphasis role="comment">//=============================================================</emphasis>
211 &#32;&#32;&#32;&#32;<link linkend="__audio_file_8h_1ad18559d169602e85d0ad68da6ef8593f">AudioFileFormat</link>&#32;audioFileFormat;
212 &#32;&#32;&#32;&#32;uint32_t&#32;sampleRate;
213 &#32;&#32;&#32;&#32;<emphasis role="keywordtype">int</emphasis>&#32;bitDepth;
214 &#32;&#32;&#32;&#32;<emphasis role="keywordtype">bool</emphasis>&#32;logErrorsToConsole&#32;{<emphasis role="keyword">true</emphasis>};
215 };
216 
217 
218 <emphasis role="comment">//=============================================================</emphasis>
219 <emphasis role="comment">//&#32;Pre-defined&#32;10-byte&#32;representations&#32;of&#32;common&#32;sample&#32;rates</emphasis>
220 <emphasis role="keyword">static</emphasis>&#32;std::unordered_map&#32;&lt;uint32_t,&#32;std::vector&lt;uint8_t&gt;&gt;&#32;aiffSampleRateTable&#32;=&#32;{
221 &#32;&#32;&#32;&#32;{8000,&#32;{64,&#32;11,&#32;250,&#32;0,&#32;0,&#32;0,&#32;0,&#32;0,&#32;0,&#32;0}},
222 &#32;&#32;&#32;&#32;{11025,&#32;{64,&#32;12,&#32;172,&#32;68,&#32;0,&#32;0,&#32;0,&#32;0,&#32;0,&#32;0}},
223 &#32;&#32;&#32;&#32;{16000,&#32;{64,&#32;12,&#32;250,&#32;0,&#32;0,&#32;0,&#32;0,&#32;0,&#32;0,&#32;0}},
224 &#32;&#32;&#32;&#32;{22050,&#32;{64,&#32;13,&#32;172,&#32;68,&#32;0,&#32;0,&#32;0,&#32;0,&#32;0,&#32;0}},
225 &#32;&#32;&#32;&#32;{32000,&#32;{64,&#32;13,&#32;250,&#32;0,&#32;0,&#32;0,&#32;0,&#32;0,&#32;0,&#32;0}},
226 &#32;&#32;&#32;&#32;{37800,&#32;{64,&#32;14,&#32;147,&#32;168,&#32;0,&#32;0,&#32;0,&#32;0,&#32;0,&#32;0}},
227 &#32;&#32;&#32;&#32;{44056,&#32;{64,&#32;14,&#32;172,&#32;24,&#32;0,&#32;0,&#32;0,&#32;0,&#32;0,&#32;0}},
228 &#32;&#32;&#32;&#32;{44100,&#32;{64,&#32;14,&#32;172,&#32;68,&#32;0,&#32;0,&#32;0,&#32;0,&#32;0,&#32;0}},
229 &#32;&#32;&#32;&#32;{47250,&#32;{64,&#32;14,&#32;184,&#32;146,&#32;0,&#32;0,&#32;0,&#32;0,&#32;0,&#32;0}},
230 &#32;&#32;&#32;&#32;{48000,&#32;{64,&#32;14,&#32;187,&#32;128,&#32;0,&#32;0,&#32;0,&#32;0,&#32;0,&#32;0}},
231 &#32;&#32;&#32;&#32;{50000,&#32;{64,&#32;14,&#32;195,&#32;80,&#32;0,&#32;0,&#32;0,&#32;0,&#32;0,&#32;0}},
232 &#32;&#32;&#32;&#32;{50400,&#32;{64,&#32;14,&#32;196,&#32;224,&#32;0,&#32;0,&#32;0,&#32;0,&#32;0,&#32;0}},
233 &#32;&#32;&#32;&#32;{88200,&#32;{64,&#32;15,&#32;172,&#32;68,&#32;0,&#32;0,&#32;0,&#32;0,&#32;0,&#32;0}},
234 &#32;&#32;&#32;&#32;{96000,&#32;{64,&#32;15,&#32;187,&#32;128,&#32;0,&#32;0,&#32;0,&#32;0,&#32;0,&#32;0}},
235 &#32;&#32;&#32;&#32;{176400,&#32;{64,&#32;16,&#32;172,&#32;68,&#32;0,&#32;0,&#32;0,&#32;0,&#32;0,&#32;0}},
236 &#32;&#32;&#32;&#32;{192000,&#32;{64,&#32;16,&#32;187,&#32;128,&#32;0,&#32;0,&#32;0,&#32;0,&#32;0,&#32;0}},
237 &#32;&#32;&#32;&#32;{352800,&#32;{64,&#32;17,&#32;172,&#32;68,&#32;0,&#32;0,&#32;0,&#32;0,&#32;0,&#32;0}},
238 &#32;&#32;&#32;&#32;{2822400,&#32;{64,&#32;20,&#32;172,&#32;68,&#32;0,&#32;0,&#32;0,&#32;0,&#32;0,&#32;0}},
239 &#32;&#32;&#32;&#32;{5644800,&#32;{64,&#32;21,&#32;172,&#32;68,&#32;0,&#32;0,&#32;0,&#32;0,&#32;0,&#32;0}}
240 };
241 
242 <emphasis role="comment">//=============================================================</emphasis>
243 <emphasis role="keyword">enum</emphasis>&#32;<link linkend="__audio_file_8h_1a24ed57f869bfefdef1bed0a033886d8e">WavAudioFormat</link>
244 {
245 &#32;&#32;&#32;&#32;<link linkend="__audio_file_8h_1a24ed57f869bfefdef1bed0a033886d8ea91062305c293c8f87879282035b9e982">PCM</link>&#32;=&#32;0x0001,
246 &#32;&#32;&#32;&#32;<link linkend="__audio_file_8h_1a24ed57f869bfefdef1bed0a033886d8eaf48e2c55df672bab9d55c60af50a7181">IEEEFloat</link>&#32;=&#32;0x0003,
247 &#32;&#32;&#32;&#32;<link linkend="__audio_file_8h_1a24ed57f869bfefdef1bed0a033886d8ea6a355409829949f68b750116a8583fe2">ALaw</link>&#32;=&#32;0x0006,
248 &#32;&#32;&#32;&#32;<link linkend="__audio_file_8h_1a24ed57f869bfefdef1bed0a033886d8ea730c7411a2c9edcad21808aea0a225d8">MULaw</link>&#32;=&#32;0x0007,
249 &#32;&#32;&#32;&#32;<link linkend="__audio_file_8h_1a24ed57f869bfefdef1bed0a033886d8ea3399988804e27576467357a9fd8fbf92">Extensible</link>&#32;=&#32;0xFFFE
250 };
251 
252 <emphasis role="comment">//=============================================================</emphasis>
253 <emphasis role="keyword">enum</emphasis>&#32;<link linkend="__audio_file_8h_1a526ed66f20752002a63ee72e2e350d7d">AIFFAudioFormat</link>
254 {
255 &#32;&#32;&#32;&#32;<link linkend="__audio_file_8h_1a526ed66f20752002a63ee72e2e350d7da8ff322ff580065823204d6a61d90f9b3">Uncompressed</link>,
256 &#32;&#32;&#32;&#32;<link linkend="__audio_file_8h_1a526ed66f20752002a63ee72e2e350d7da4e27fd9489beea00d95846abc48ab83e">Compressed</link>,
257 &#32;&#32;&#32;&#32;<link linkend="__audio_file_8h_1a526ed66f20752002a63ee72e2e350d7da4dfd42ec49d09d8c6555c218301cc30f">Error</link>
258 };
259 
260 <emphasis role="comment">//=============================================================</emphasis>
261 <emphasis role="comment">/*&#32;IMPLEMENTATION&#32;*/</emphasis>
262 <emphasis role="comment">//=============================================================</emphasis>
263 
264 <emphasis role="comment">//=============================================================</emphasis>
265 <emphasis role="keyword">template</emphasis>&#32;&lt;<emphasis role="keyword">class</emphasis>&#32;T&gt;
266 <link linkend="_class_audio_file_1ae74399e93d3f4623c7421ee10cfc0e15">AudioFile&lt;T&gt;::AudioFile</link>()
267 {
268 &#32;&#32;&#32;&#32;<emphasis role="keyword">static_assert</emphasis>(std::is_floating_point&lt;T&gt;::value,&#32;<emphasis role="stringliteral">&quot;ERROR:&#32;This&#32;version&#32;of&#32;AudioFile&#32;only&#32;supports&#32;floating&#32;point&#32;sample&#32;formats&quot;</emphasis>);
269 
270 &#32;&#32;&#32;&#32;<link linkend="_namespaceaiff__stereo__16bit__44100_1a9437286c09cbbda5f152c5a5e231eda5">bitDepth</link>&#32;=&#32;16;
271 &#32;&#32;&#32;&#32;<link linkend="_namespaceaiff__stereo__16bit__44100_1a495b7a67f7fb515c0a5df8139c44e8c4">sampleRate</link>&#32;=&#32;44100;
272 &#32;&#32;&#32;&#32;samples.resize&#32;(1);
273 &#32;&#32;&#32;&#32;samples[0].resize&#32;(0);
274 &#32;&#32;&#32;&#32;audioFileFormat&#32;=&#32;<link linkend="__audio_file_8h_1ad18559d169602e85d0ad68da6ef8593fa5111e24c1ecc6266ce0de4b4dc42033b">AudioFileFormat::NotLoaded</link>;
275 }
276 
277 <emphasis role="comment">//=============================================================</emphasis>
278 <emphasis role="keyword">template</emphasis>&#32;&lt;<emphasis role="keyword">class</emphasis>&#32;T&gt;
279 <link linkend="_class_audio_file_1ae74399e93d3f4623c7421ee10cfc0e15">AudioFile&lt;T&gt;::AudioFile</link>&#32;(std::string&#32;filePath)
280 &#32;:&#32;&#32;<link linkend="_class_audio_file">AudioFile</link>&lt;T&gt;()
281 {
282 &#32;&#32;&#32;&#32;<link linkend="_class_audio_file_1a0ff16123b519a4665e9f3e7d341f0a26">load</link>&#32;(filePath);
283 }
284 
285 <emphasis role="comment">//=============================================================</emphasis>
286 <emphasis role="keyword">template</emphasis>&#32;&lt;<emphasis role="keyword">class</emphasis>&#32;T&gt;
287 uint32_t&#32;<link linkend="_class_audio_file_1a8cd1b082af9db6bd180e4a63edcdefc9">AudioFile&lt;T&gt;::getSampleRate</link>()<emphasis role="keyword">&#32;const</emphasis>
288 <emphasis role="keyword"></emphasis>{
289 &#32;&#32;&#32;&#32;<emphasis role="keywordflow">return</emphasis>&#32;<link linkend="_namespaceaiff__stereo__16bit__44100_1a495b7a67f7fb515c0a5df8139c44e8c4">sampleRate</link>;
290 }
291 
292 <emphasis role="comment">//=============================================================</emphasis>
293 <emphasis role="keyword">template</emphasis>&#32;&lt;<emphasis role="keyword">class</emphasis>&#32;T&gt;
294 <emphasis role="keywordtype">int</emphasis>&#32;<link linkend="_class_audio_file_1a514f860a956b4494ee8d8c806391d6b3">AudioFile&lt;T&gt;::getNumChannels</link>()<emphasis role="keyword">&#32;const</emphasis>
295 <emphasis role="keyword"></emphasis>{
296 &#32;&#32;&#32;&#32;<emphasis role="keywordflow">return</emphasis>&#32;(<emphasis role="keywordtype">int</emphasis>)samples.size();
297 }
298 
299 <emphasis role="comment">//=============================================================</emphasis>
300 <emphasis role="keyword">template</emphasis>&#32;&lt;<emphasis role="keyword">class</emphasis>&#32;T&gt;
301 <emphasis role="keywordtype">bool</emphasis>&#32;<link linkend="_class_audio_file_1a1057326fd2c2eca7cc7937f811868cf1">AudioFile&lt;T&gt;::isMono</link>()<emphasis role="keyword">&#32;const</emphasis>
302 <emphasis role="keyword"></emphasis>{
303 &#32;&#32;&#32;&#32;<emphasis role="keywordflow">return</emphasis>&#32;getNumChannels()&#32;==&#32;1;
304 }
305 
306 <emphasis role="comment">//=============================================================</emphasis>
307 <emphasis role="keyword">template</emphasis>&#32;&lt;<emphasis role="keyword">class</emphasis>&#32;T&gt;
308 <emphasis role="keywordtype">bool</emphasis>&#32;<link linkend="_class_audio_file_1a380a188d95f8f23b7622dfe222a7e8f6">AudioFile&lt;T&gt;::isStereo</link>()<emphasis role="keyword">&#32;const</emphasis>
309 <emphasis role="keyword"></emphasis>{
310 &#32;&#32;&#32;&#32;<emphasis role="keywordflow">return</emphasis>&#32;getNumChannels()&#32;==&#32;2;
311 }
312 
313 <emphasis role="comment">//=============================================================</emphasis>
314 <emphasis role="keyword">template</emphasis>&#32;&lt;<emphasis role="keyword">class</emphasis>&#32;T&gt;
315 <emphasis role="keywordtype">int</emphasis>&#32;<link linkend="_class_audio_file_1a5495d5cb55911de54f0714e219130b48">AudioFile&lt;T&gt;::getBitDepth</link>()<emphasis role="keyword">&#32;const</emphasis>
316 <emphasis role="keyword"></emphasis>{
317 &#32;&#32;&#32;&#32;<emphasis role="keywordflow">return</emphasis>&#32;<link linkend="_namespaceaiff__stereo__16bit__44100_1a9437286c09cbbda5f152c5a5e231eda5">bitDepth</link>;
318 }
319 
320 <emphasis role="comment">//=============================================================</emphasis>
321 <emphasis role="keyword">template</emphasis>&#32;&lt;<emphasis role="keyword">class</emphasis>&#32;T&gt;
322 <emphasis role="keywordtype">int</emphasis>&#32;<link linkend="_class_audio_file_1ae1b5b4b7351a79dbf810bb34ede496b9">AudioFile&lt;T&gt;::getNumSamplesPerChannel</link>()<emphasis role="keyword">&#32;const</emphasis>
323 <emphasis role="keyword"></emphasis>{
324 &#32;&#32;&#32;&#32;<emphasis role="keywordflow">if</emphasis>&#32;(samples.size()&#32;&gt;&#32;0)
325 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keywordflow">return</emphasis>&#32;(<emphasis role="keywordtype">int</emphasis>)&#32;samples[0].size();
326 &#32;&#32;&#32;&#32;<emphasis role="keywordflow">else</emphasis>
327 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keywordflow">return</emphasis>&#32;0;
328 }
329 
330 <emphasis role="comment">//=============================================================</emphasis>
331 <emphasis role="keyword">template</emphasis>&#32;&lt;<emphasis role="keyword">class</emphasis>&#32;T&gt;
332 <emphasis role="keywordtype">double</emphasis>&#32;<link linkend="_class_audio_file_1a5a6b01404675361b1c21c9c5fb5753d4">AudioFile&lt;T&gt;::getLengthInSeconds</link>()<emphasis role="keyword">&#32;const</emphasis>
333 <emphasis role="keyword"></emphasis>{
334 &#32;&#32;&#32;&#32;<emphasis role="keywordflow">return</emphasis>&#32;(<emphasis role="keywordtype">double</emphasis>)getNumSamplesPerChannel()&#32;/&#32;(double)<link linkend="_namespaceaiff__stereo__16bit__44100_1a495b7a67f7fb515c0a5df8139c44e8c4">sampleRate</link>;
335 }
336 
337 <emphasis role="comment">//=============================================================</emphasis>
338 <emphasis role="keyword">template</emphasis>&#32;&lt;<emphasis role="keyword">class</emphasis>&#32;T&gt;
339 <emphasis role="keywordtype">void</emphasis>&#32;<link linkend="_class_audio_file_1a7b88c68133a9ac92149c58499e026360">AudioFile&lt;T&gt;::printSummary</link>()<emphasis role="keyword">&#32;const</emphasis>
340 <emphasis role="keyword"></emphasis>{
341 &#32;&#32;&#32;&#32;std::cout&#32;&lt;&lt;&#32;<emphasis role="stringliteral">&quot;|======================================|&quot;</emphasis>&#32;&lt;&lt;&#32;std::endl;
342 &#32;&#32;&#32;&#32;std::cout&#32;&lt;&lt;&#32;<emphasis role="stringliteral">&quot;Num&#32;Channels:&#32;&quot;</emphasis>&#32;&lt;&lt;&#32;getNumChannels()&#32;&lt;&lt;&#32;std::endl;
343 &#32;&#32;&#32;&#32;std::cout&#32;&lt;&lt;&#32;<emphasis role="stringliteral">&quot;Num&#32;Samples&#32;Per&#32;Channel:&#32;&quot;</emphasis>&#32;&lt;&lt;&#32;getNumSamplesPerChannel()&#32;&lt;&lt;&#32;std::endl;
344 &#32;&#32;&#32;&#32;std::cout&#32;&lt;&lt;&#32;<emphasis role="stringliteral">&quot;Sample&#32;Rate:&#32;&quot;</emphasis>&#32;&lt;&lt;&#32;<link linkend="_namespaceaiff__stereo__16bit__44100_1a495b7a67f7fb515c0a5df8139c44e8c4">sampleRate</link>&#32;&lt;&lt;&#32;std::endl;
345 &#32;&#32;&#32;&#32;std::cout&#32;&lt;&lt;&#32;<emphasis role="stringliteral">&quot;Bit&#32;Depth:&#32;&quot;</emphasis>&#32;&lt;&lt;&#32;<link linkend="_namespaceaiff__stereo__16bit__44100_1a9437286c09cbbda5f152c5a5e231eda5">bitDepth</link>&#32;&lt;&lt;&#32;std::endl;
346 &#32;&#32;&#32;&#32;std::cout&#32;&lt;&lt;&#32;<emphasis role="stringliteral">&quot;Length&#32;in&#32;Seconds:&#32;&quot;</emphasis>&#32;&lt;&lt;&#32;getLengthInSeconds()&#32;&lt;&lt;&#32;std::endl;
347 &#32;&#32;&#32;&#32;std::cout&#32;&lt;&lt;&#32;<emphasis role="stringliteral">&quot;|======================================|&quot;</emphasis>&#32;&lt;&lt;&#32;std::endl;
348 }
349 
350 <emphasis role="comment">//=============================================================</emphasis>
351 <emphasis role="keyword">template</emphasis>&#32;&lt;<emphasis role="keyword">class</emphasis>&#32;T&gt;
352 <emphasis role="keywordtype">bool</emphasis>&#32;<link linkend="_class_audio_file_1afa0a0f7d576b0597c938c5a89746636e">AudioFile&lt;T&gt;::setAudioBuffer</link>&#32;(<link linkend="_class_audio_file_1ad1260a47791dc30cbabfe3ff2ea099b1">AudioBuffer</link>&amp;&#32;newBuffer)
353 {
354 &#32;&#32;&#32;&#32;<emphasis role="keywordtype">int</emphasis>&#32;<link linkend="_namespacemake_headers_1aebae91248540ba01faf787f19070a220">numChannels</link>&#32;=&#32;(int)newBuffer.size();
355 &#32;&#32;&#32;&#32;
356 &#32;&#32;&#32;&#32;<emphasis role="keywordflow">if</emphasis>&#32;(<link linkend="_namespacemake_headers_1aebae91248540ba01faf787f19070a220">numChannels</link>&#32;&lt;=&#32;0)
357 &#32;&#32;&#32;&#32;{
358 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;assert&#32;(<emphasis role="keyword">false</emphasis>&#32;&amp;&amp;&#32;<emphasis role="stringliteral">&quot;The&#32;buffer&#32;your&#32;are&#32;trying&#32;to&#32;use&#32;has&#32;no&#32;channels&quot;</emphasis>);
359 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keywordflow">return</emphasis>&#32;<emphasis role="keyword">false</emphasis>;
360 &#32;&#32;&#32;&#32;}
361 &#32;&#32;&#32;&#32;
362 &#32;&#32;&#32;&#32;<emphasis role="keywordtype">size_t</emphasis>&#32;numSamples&#32;=&#32;newBuffer[0].size();
363 &#32;&#32;&#32;&#32;
364 &#32;&#32;&#32;&#32;<emphasis role="comment">//&#32;set&#32;the&#32;number&#32;of&#32;channels</emphasis>
365 &#32;&#32;&#32;&#32;samples.resize&#32;(newBuffer.size());
366 &#32;&#32;&#32;&#32;
367 &#32;&#32;&#32;&#32;<emphasis role="keywordflow">for</emphasis>&#32;(<emphasis role="keywordtype">int</emphasis>&#32;k&#32;=&#32;0;&#32;k&#32;&lt;&#32;getNumChannels();&#32;k++)
368 &#32;&#32;&#32;&#32;{
369 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;assert&#32;(newBuffer[k].size()&#32;==&#32;numSamples);
370 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;
371 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;samples[k].resize&#32;(numSamples);
372 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;
373 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keywordflow">for</emphasis>&#32;(<emphasis role="keywordtype">size_t</emphasis>&#32;i&#32;=&#32;0;&#32;i&#32;&lt;&#32;numSamples;&#32;i++)
374 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;{
375 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;samples[k][i]&#32;=&#32;newBuffer[k][i];
376 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;}
377 &#32;&#32;&#32;&#32;}
378 &#32;&#32;&#32;&#32;
379 &#32;&#32;&#32;&#32;<emphasis role="keywordflow">return</emphasis>&#32;<emphasis role="keyword">true</emphasis>;
380 }
381 
382 <emphasis role="comment">//=============================================================</emphasis>
383 <emphasis role="keyword">template</emphasis>&#32;&lt;<emphasis role="keyword">class</emphasis>&#32;T&gt;
384 <emphasis role="keywordtype">void</emphasis>&#32;<link linkend="_class_audio_file_1ac155ed12db0f3b02011a7d75b525e71a">AudioFile&lt;T&gt;::setAudioBufferSize</link>&#32;(<emphasis role="keywordtype">int</emphasis>&#32;<link linkend="_namespacemake_headers_1aebae91248540ba01faf787f19070a220">numChannels</link>,&#32;<emphasis role="keywordtype">int</emphasis>&#32;numSamples)
385 {
386 &#32;&#32;&#32;&#32;samples.resize&#32;(<link linkend="_namespacemake_headers_1aebae91248540ba01faf787f19070a220">numChannels</link>);
387 &#32;&#32;&#32;&#32;setNumSamplesPerChannel&#32;(numSamples);
388 }
389 
390 <emphasis role="comment">//=============================================================</emphasis>
391 <emphasis role="keyword">template</emphasis>&#32;&lt;<emphasis role="keyword">class</emphasis>&#32;T&gt;
392 <emphasis role="keywordtype">void</emphasis>&#32;<link linkend="_class_audio_file_1a4cff9513d49e21d25de13513564784b7">AudioFile&lt;T&gt;::setNumSamplesPerChannel</link>&#32;(<emphasis role="keywordtype">int</emphasis>&#32;numSamples)
393 {
394 &#32;&#32;&#32;&#32;<emphasis role="keywordtype">int</emphasis>&#32;originalSize&#32;=&#32;getNumSamplesPerChannel();
395 &#32;&#32;&#32;&#32;
396 &#32;&#32;&#32;&#32;<emphasis role="keywordflow">for</emphasis>&#32;(<emphasis role="keywordtype">int</emphasis>&#32;i&#32;=&#32;0;&#32;i&#32;&lt;&#32;getNumChannels();i++)
397 &#32;&#32;&#32;&#32;{
398 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;samples[i].resize&#32;(numSamples);
399 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;
400 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="comment">//&#32;set&#32;any&#32;new&#32;samples&#32;to&#32;zero</emphasis>
401 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keywordflow">if</emphasis>&#32;(numSamples&#32;&gt;&#32;originalSize)
402 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;std::fill&#32;(samples[i].begin()&#32;+&#32;originalSize,&#32;samples[i].end(),&#32;(T)0.);
403 &#32;&#32;&#32;&#32;}
404 }
405 
406 <emphasis role="comment">//=============================================================</emphasis>
407 <emphasis role="keyword">template</emphasis>&#32;&lt;<emphasis role="keyword">class</emphasis>&#32;T&gt;
408 <emphasis role="keywordtype">void</emphasis>&#32;<link linkend="_class_audio_file_1a354018a94ae15907d7308782f2adadbb">AudioFile&lt;T&gt;::setNumChannels</link>&#32;(<emphasis role="keywordtype">int</emphasis>&#32;<link linkend="_namespacemake_headers_1aebae91248540ba01faf787f19070a220">numChannels</link>)
409 {
410 &#32;&#32;&#32;&#32;<emphasis role="keywordtype">int</emphasis>&#32;originalNumChannels&#32;=&#32;getNumChannels();
411 &#32;&#32;&#32;&#32;<emphasis role="keywordtype">int</emphasis>&#32;originalNumSamplesPerChannel&#32;=&#32;getNumSamplesPerChannel();
412 &#32;&#32;&#32;&#32;
413 &#32;&#32;&#32;&#32;samples.resize&#32;(<link linkend="_namespacemake_headers_1aebae91248540ba01faf787f19070a220">numChannels</link>);
414 &#32;&#32;&#32;&#32;
415 &#32;&#32;&#32;&#32;<emphasis role="comment">//&#32;make&#32;sure&#32;any&#32;new&#32;channels&#32;are&#32;set&#32;to&#32;the&#32;right&#32;size</emphasis>
416 &#32;&#32;&#32;&#32;<emphasis role="comment">//&#32;and&#32;filled&#32;with&#32;zeros</emphasis>
417 &#32;&#32;&#32;&#32;<emphasis role="keywordflow">if</emphasis>&#32;(<link linkend="_namespacemake_headers_1aebae91248540ba01faf787f19070a220">numChannels</link>&#32;&gt;&#32;originalNumChannels)
418 &#32;&#32;&#32;&#32;{
419 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keywordflow">for</emphasis>&#32;(<emphasis role="keywordtype">int</emphasis>&#32;i&#32;=&#32;originalNumChannels;&#32;i&#32;&lt;&#32;<link linkend="_namespacemake_headers_1aebae91248540ba01faf787f19070a220">numChannels</link>;&#32;i++)
420 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;{
421 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;samples[i].resize&#32;(originalNumSamplesPerChannel);
422 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;std::fill&#32;(samples[i].begin(),&#32;samples[i].end(),&#32;(T)0.);
423 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;}
424 &#32;&#32;&#32;&#32;}
425 }
426 
427 <emphasis role="comment">//=============================================================</emphasis>
428 <emphasis role="keyword">template</emphasis>&#32;&lt;<emphasis role="keyword">class</emphasis>&#32;T&gt;
429 <emphasis role="keywordtype">void</emphasis>&#32;<link linkend="_class_audio_file_1a2adf2ea23e7daeb8401e717c1b3d874b">AudioFile&lt;T&gt;::setBitDepth</link>&#32;(<emphasis role="keywordtype">int</emphasis>&#32;numBitsPerSample)
430 {
431 &#32;&#32;&#32;&#32;<link linkend="_namespaceaiff__stereo__16bit__44100_1a9437286c09cbbda5f152c5a5e231eda5">bitDepth</link>&#32;=&#32;numBitsPerSample;
432 }
433 
434 <emphasis role="comment">//=============================================================</emphasis>
435 <emphasis role="keyword">template</emphasis>&#32;&lt;<emphasis role="keyword">class</emphasis>&#32;T&gt;
436 <emphasis role="keywordtype">void</emphasis>&#32;<link linkend="_class_audio_file_1a2d8fa306e40535113c3eba111e16483b">AudioFile&lt;T&gt;::setSampleRate</link>&#32;(uint32_t&#32;newSampleRate)
437 {
438 &#32;&#32;&#32;&#32;<link linkend="_namespaceaiff__stereo__16bit__44100_1a495b7a67f7fb515c0a5df8139c44e8c4">sampleRate</link>&#32;=&#32;newSampleRate;
439 }
440 
441 <emphasis role="comment">//=============================================================</emphasis>
442 <emphasis role="keyword">template</emphasis>&#32;&lt;<emphasis role="keyword">class</emphasis>&#32;T&gt;
443 <emphasis role="keywordtype">void</emphasis>&#32;<link linkend="_class_audio_file_1a1986c0297e4e4db99435702528e9c3c4">AudioFile&lt;T&gt;::shouldLogErrorsToConsole</link>&#32;(<emphasis role="keywordtype">bool</emphasis>&#32;logErrors)
444 {
445 &#32;&#32;&#32;&#32;logErrorsToConsole&#32;=&#32;logErrors;
446 }
447 
448 <emphasis role="comment">//=============================================================</emphasis>
449 <emphasis role="keyword">template</emphasis>&#32;&lt;<emphasis role="keyword">class</emphasis>&#32;T&gt;
450 <emphasis role="keywordtype">bool</emphasis>&#32;<link linkend="_class_audio_file_1a0ff16123b519a4665e9f3e7d341f0a26">AudioFile&lt;T&gt;::load</link>&#32;(std::string&#32;filePath)
451 {
452 &#32;&#32;&#32;&#32;std::ifstream&#32;file&#32;(filePath,&#32;std::ios::binary);
453 &#32;&#32;&#32;&#32;
454 &#32;&#32;&#32;&#32;<emphasis role="comment">//&#32;check&#32;the&#32;file&#32;exists</emphasis>
455 &#32;&#32;&#32;&#32;<emphasis role="keywordflow">if</emphasis>&#32;(!&#32;file.good())
456 &#32;&#32;&#32;&#32;{
457 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;reportError&#32;(<emphasis role="stringliteral">&quot;ERROR:&#32;File&#32;doesn&apos;t&#32;exist&#32;or&#32;otherwise&#32;can&apos;t&#32;load&#32;file\n&quot;</emphasis>&#32;&#32;+&#32;filePath);
458 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keywordflow">return</emphasis>&#32;<emphasis role="keyword">false</emphasis>;
459 &#32;&#32;&#32;&#32;}
460 &#32;&#32;&#32;&#32;
461 &#32;&#32;&#32;&#32;std::vector&lt;uint8_t&gt;&#32;fileData;
462 
463 &#32;&#32;&#32;&#32;file.unsetf&#32;(std::ios::skipws);
464 
465 &#32;&#32;&#32;&#32;file.seekg&#32;(0,&#32;std::ios::end);
466 &#32;&#32;&#32;&#32;<emphasis role="keywordtype">size_t</emphasis>&#32;length&#32;=&#32;file.tellg();
467 &#32;&#32;&#32;&#32;file.seekg&#32;(0,&#32;std::ios::beg);
468 
469 &#32;&#32;&#32;&#32;<emphasis role="comment">//&#32;allocate</emphasis>
470 &#32;&#32;&#32;&#32;fileData.resize&#32;(length);
471 
472 &#32;&#32;&#32;&#32;file.read(<emphasis role="keyword">reinterpret_cast&lt;</emphasis><emphasis role="keywordtype">char</emphasis>*<emphasis role="keyword">&gt;</emphasis>&#32;(fileData.data()),&#32;length);
473 &#32;&#32;&#32;&#32;file.close();
474 
475 &#32;&#32;&#32;&#32;<emphasis role="keywordflow">if</emphasis>&#32;(file.gcount()&#32;!=&#32;length)
476 &#32;&#32;&#32;&#32;{
477 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;reportError&#32;(<emphasis role="stringliteral">&quot;ERROR:&#32;Couldn&apos;t&#32;read&#32;entire&#32;file\n&quot;</emphasis>&#32;+&#32;filePath);
478 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keywordflow">return</emphasis>&#32;<emphasis role="keyword">false</emphasis>;
479 &#32;&#32;&#32;&#32;}
480 &#32;&#32;&#32;&#32;
481 &#32;&#32;&#32;&#32;<emphasis role="comment">//&#32;get&#32;audio&#32;file&#32;format</emphasis>
482 &#32;&#32;&#32;&#32;audioFileFormat&#32;=&#32;determineAudioFileFormat&#32;(fileData);
483 &#32;&#32;&#32;&#32;
484 &#32;&#32;&#32;&#32;<emphasis role="keywordflow">if</emphasis>&#32;(audioFileFormat&#32;==&#32;<link linkend="__audio_file_8h_1ad18559d169602e85d0ad68da6ef8593fad911b34823c7674c292556dc56148c27">AudioFileFormat::Wave</link>)
485 &#32;&#32;&#32;&#32;{
486 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keywordflow">return</emphasis>&#32;decodeWaveFile&#32;(fileData);
487 &#32;&#32;&#32;&#32;}
488 &#32;&#32;&#32;&#32;<emphasis role="keywordflow">else</emphasis>&#32;<emphasis role="keywordflow">if</emphasis>&#32;(audioFileFormat&#32;==&#32;<link linkend="__audio_file_8h_1ad18559d169602e85d0ad68da6ef8593fac2271ab764905d770a81d0920f8c6aaf">AudioFileFormat::Aiff</link>)
489 &#32;&#32;&#32;&#32;{
490 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keywordflow">return</emphasis>&#32;decodeAiffFile&#32;(fileData);
491 &#32;&#32;&#32;&#32;}
492 &#32;&#32;&#32;&#32;<emphasis role="keywordflow">else</emphasis>
493 &#32;&#32;&#32;&#32;{
494 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;reportError&#32;(<emphasis role="stringliteral">&quot;Audio&#32;File&#32;Type:&#32;Error&quot;</emphasis>);
495 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keywordflow">return</emphasis>&#32;<emphasis role="keyword">false</emphasis>;
496 &#32;&#32;&#32;&#32;}
497 }
498 
499 <emphasis role="comment">//=============================================================</emphasis>
500 <emphasis role="keyword">template</emphasis>&#32;&lt;<emphasis role="keyword">class</emphasis>&#32;T&gt;
501 <emphasis role="keywordtype">bool</emphasis>&#32;<link linkend="_class_audio_file">AudioFile&lt;T&gt;::decodeWaveFile</link>&#32;(std::vector&lt;uint8_t&gt;&amp;&#32;fileData)
502 {
503 &#32;&#32;&#32;&#32;<emphasis role="comment">//&#32;-----------------------------------------------------------</emphasis>
504 &#32;&#32;&#32;&#32;<emphasis role="comment">//&#32;HEADER&#32;CHUNK</emphasis>
505 &#32;&#32;&#32;&#32;std::string&#32;headerChunkID&#32;(fileData.begin(),&#32;fileData.begin()&#32;+&#32;4);
506 &#32;&#32;&#32;&#32;<emphasis role="comment">//int32_t&#32;fileSizeInBytes&#32;=&#32;fourBytesToInt&#32;(fileData,&#32;4)&#32;+&#32;8;</emphasis>
507 &#32;&#32;&#32;&#32;std::string&#32;format&#32;(fileData.begin()&#32;+&#32;8,&#32;fileData.begin()&#32;+&#32;12);
508 &#32;&#32;&#32;&#32;
509 &#32;&#32;&#32;&#32;<emphasis role="comment">//&#32;-----------------------------------------------------------</emphasis>
510 &#32;&#32;&#32;&#32;<emphasis role="comment">//&#32;try&#32;and&#32;find&#32;the&#32;start&#32;points&#32;of&#32;key&#32;chunks</emphasis>
511 &#32;&#32;&#32;&#32;<emphasis role="keywordtype">int</emphasis>&#32;indexOfDataChunk&#32;=&#32;getIndexOfChunk&#32;(fileData,&#32;<emphasis role="stringliteral">&quot;data&quot;</emphasis>,&#32;12);
512 &#32;&#32;&#32;&#32;<emphasis role="keywordtype">int</emphasis>&#32;indexOfFormatChunk&#32;=&#32;getIndexOfChunk&#32;(fileData,&#32;<emphasis role="stringliteral">&quot;fmt&#32;&quot;</emphasis>,&#32;12);
513 &#32;&#32;&#32;&#32;<emphasis role="keywordtype">int</emphasis>&#32;indexOfXMLChunk&#32;=&#32;getIndexOfChunk&#32;(fileData,&#32;<emphasis role="stringliteral">&quot;iXML&quot;</emphasis>,&#32;12);
514 &#32;&#32;&#32;&#32;
515 &#32;&#32;&#32;&#32;<emphasis role="comment">//&#32;if&#32;we&#32;can&apos;t&#32;find&#32;the&#32;data&#32;or&#32;format&#32;chunks,&#32;or&#32;the&#32;IDs/formats&#32;don&apos;t&#32;seem&#32;to&#32;be&#32;as&#32;expected</emphasis>
516 &#32;&#32;&#32;&#32;<emphasis role="comment">//&#32;then&#32;it&#32;is&#32;unlikely&#32;we&apos;ll&#32;able&#32;to&#32;read&#32;this&#32;file,&#32;so&#32;abort</emphasis>
517 &#32;&#32;&#32;&#32;<emphasis role="keywordflow">if</emphasis>&#32;(indexOfDataChunk&#32;==&#32;-1&#32;||&#32;indexOfFormatChunk&#32;==&#32;-1&#32;||&#32;headerChunkID&#32;!=&#32;<emphasis role="stringliteral">&quot;RIFF&quot;</emphasis>&#32;||&#32;format&#32;!=&#32;<emphasis role="stringliteral">&quot;WAVE&quot;</emphasis>)
518 &#32;&#32;&#32;&#32;{
519 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;reportError&#32;(<emphasis role="stringliteral">&quot;ERROR:&#32;this&#32;doesn&apos;t&#32;seem&#32;to&#32;be&#32;a&#32;valid&#32;.WAV&#32;file&quot;</emphasis>);
520 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keywordflow">return</emphasis>&#32;<emphasis role="keyword">false</emphasis>;
521 &#32;&#32;&#32;&#32;}
522 &#32;&#32;&#32;&#32;
523 &#32;&#32;&#32;&#32;<emphasis role="comment">//&#32;-----------------------------------------------------------</emphasis>
524 &#32;&#32;&#32;&#32;<emphasis role="comment">//&#32;FORMAT&#32;CHUNK</emphasis>
525 &#32;&#32;&#32;&#32;<emphasis role="keywordtype">int</emphasis>&#32;f&#32;=&#32;indexOfFormatChunk;
526 &#32;&#32;&#32;&#32;std::string&#32;formatChunkID&#32;(fileData.begin()&#32;+&#32;f,&#32;fileData.begin()&#32;+&#32;f&#32;+&#32;4);
527 &#32;&#32;&#32;&#32;<emphasis role="comment">//int32_t&#32;formatChunkSize&#32;=&#32;fourBytesToInt&#32;(fileData,&#32;f&#32;+&#32;4);</emphasis>
528 &#32;&#32;&#32;&#32;uint16_t&#32;audioFormat&#32;=&#32;twoBytesToInt&#32;(fileData,&#32;f&#32;+&#32;8);
529 &#32;&#32;&#32;&#32;uint16_t&#32;<link linkend="_namespacemake_headers_1aebae91248540ba01faf787f19070a220">numChannels</link>&#32;=&#32;twoBytesToInt&#32;(fileData,&#32;f&#32;+&#32;10);
530 &#32;&#32;&#32;&#32;<link linkend="_namespaceaiff__stereo__16bit__44100_1a495b7a67f7fb515c0a5df8139c44e8c4">sampleRate</link>&#32;=&#32;(uint32_t)&#32;fourBytesToInt&#32;(fileData,&#32;f&#32;+&#32;12);
531 &#32;&#32;&#32;&#32;uint32_t&#32;numBytesPerSecond&#32;=&#32;fourBytesToInt&#32;(fileData,&#32;f&#32;+&#32;16);
532 &#32;&#32;&#32;&#32;uint16_t&#32;numBytesPerBlock&#32;=&#32;twoBytesToInt&#32;(fileData,&#32;f&#32;+&#32;20);
533 &#32;&#32;&#32;&#32;<link linkend="_namespaceaiff__stereo__16bit__44100_1a9437286c09cbbda5f152c5a5e231eda5">bitDepth</link>&#32;=&#32;(int)&#32;twoBytesToInt&#32;(fileData,&#32;f&#32;+&#32;22);
534 &#32;&#32;&#32;&#32;
535 &#32;&#32;&#32;&#32;uint16_t&#32;numBytesPerSample&#32;=&#32;<emphasis role="keyword">static_cast&lt;</emphasis>uint16_t<emphasis role="keyword">&gt;</emphasis>&#32;(<link linkend="_namespaceaiff__stereo__16bit__44100_1a9437286c09cbbda5f152c5a5e231eda5">bitDepth</link>)&#32;/&#32;8;
536 &#32;&#32;&#32;&#32;
537 &#32;&#32;&#32;&#32;<emphasis role="comment">//&#32;check&#32;that&#32;the&#32;audio&#32;format&#32;is&#32;PCM&#32;or&#32;Float&#32;or&#32;extensible</emphasis>
538 &#32;&#32;&#32;&#32;<emphasis role="keywordflow">if</emphasis>&#32;(audioFormat&#32;!=&#32;<link linkend="__audio_file_8h_1a24ed57f869bfefdef1bed0a033886d8ea91062305c293c8f87879282035b9e982">WavAudioFormat::PCM</link>&#32;&amp;&amp;&#32;audioFormat&#32;!=&#32;<link linkend="__audio_file_8h_1a24ed57f869bfefdef1bed0a033886d8eaf48e2c55df672bab9d55c60af50a7181">WavAudioFormat::IEEEFloat</link>&#32;&amp;&amp;&#32;audioFormat&#32;!=&#32;<link linkend="__audio_file_8h_1a24ed57f869bfefdef1bed0a033886d8ea3399988804e27576467357a9fd8fbf92">WavAudioFormat::Extensible</link>)
539 &#32;&#32;&#32;&#32;{
540 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;reportError&#32;(<emphasis role="stringliteral">&quot;ERROR:&#32;this&#32;.WAV&#32;file&#32;is&#32;encoded&#32;in&#32;a&#32;format&#32;that&#32;this&#32;library&#32;does&#32;not&#32;support&#32;at&#32;present&quot;</emphasis>);
541 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keywordflow">return</emphasis>&#32;<emphasis role="keyword">false</emphasis>;
542 &#32;&#32;&#32;&#32;}
543 &#32;&#32;&#32;&#32;
544 &#32;&#32;&#32;&#32;<emphasis role="comment">//&#32;check&#32;the&#32;number&#32;of&#32;channels&#32;is&#32;mono&#32;or&#32;stereo</emphasis>
545 &#32;&#32;&#32;&#32;<emphasis role="keywordflow">if</emphasis>&#32;(numChannels&#32;&lt;&#32;1&#32;||&#32;numChannels&#32;&gt;&#32;128)
546 &#32;&#32;&#32;&#32;{
547 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;reportError&#32;(<emphasis role="stringliteral">&quot;ERROR:&#32;this&#32;WAV&#32;file&#32;seems&#32;to&#32;be&#32;an&#32;invalid&#32;number&#32;of&#32;channels&#32;(or&#32;corrupted?)&quot;</emphasis>);
548 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keywordflow">return</emphasis>&#32;<emphasis role="keyword">false</emphasis>;
549 &#32;&#32;&#32;&#32;}
550 &#32;&#32;&#32;&#32;
551 &#32;&#32;&#32;&#32;<emphasis role="comment">//&#32;check&#32;header&#32;data&#32;is&#32;consistent</emphasis>
552 &#32;&#32;&#32;&#32;<emphasis role="keywordflow">if</emphasis>&#32;(numBytesPerSecond&#32;!=&#32;<emphasis role="keyword">static_cast&lt;</emphasis>uint32_t<emphasis role="keyword">&gt;</emphasis>&#32;((<link linkend="_namespacemake_headers_1aebae91248540ba01faf787f19070a220">numChannels</link>&#32;*&#32;<link linkend="_namespaceaiff__stereo__16bit__44100_1a495b7a67f7fb515c0a5df8139c44e8c4">sampleRate</link>&#32;*&#32;<link linkend="_namespaceaiff__stereo__16bit__44100_1a9437286c09cbbda5f152c5a5e231eda5">bitDepth</link>)&#32;/&#32;8)&#32;||&#32;numBytesPerBlock&#32;!=&#32;(<link linkend="_namespacemake_headers_1aebae91248540ba01faf787f19070a220">numChannels</link>&#32;*&#32;numBytesPerSample))
553 &#32;&#32;&#32;&#32;{
554 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;reportError&#32;(<emphasis role="stringliteral">&quot;ERROR:&#32;the&#32;header&#32;data&#32;in&#32;this&#32;WAV&#32;file&#32;seems&#32;to&#32;be&#32;inconsistent&quot;</emphasis>);
555 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keywordflow">return</emphasis>&#32;<emphasis role="keyword">false</emphasis>;
556 &#32;&#32;&#32;&#32;}
557 &#32;&#32;&#32;&#32;
558 &#32;&#32;&#32;&#32;<emphasis role="comment">//&#32;check&#32;bit&#32;depth&#32;is&#32;either&#32;8,&#32;16,&#32;24&#32;or&#32;32&#32;bit</emphasis>
559 &#32;&#32;&#32;&#32;<emphasis role="keywordflow">if</emphasis>&#32;(<link linkend="_namespaceaiff__stereo__16bit__44100_1a9437286c09cbbda5f152c5a5e231eda5">bitDepth</link>&#32;!=&#32;8&#32;&amp;&amp;&#32;<link linkend="_namespaceaiff__stereo__16bit__44100_1a9437286c09cbbda5f152c5a5e231eda5">bitDepth</link>&#32;!=&#32;16&#32;&amp;&amp;&#32;<link linkend="_namespaceaiff__stereo__16bit__44100_1a9437286c09cbbda5f152c5a5e231eda5">bitDepth</link>&#32;!=&#32;24&#32;&amp;&amp;&#32;<link linkend="_namespaceaiff__stereo__16bit__44100_1a9437286c09cbbda5f152c5a5e231eda5">bitDepth</link>&#32;!=&#32;32)
560 &#32;&#32;&#32;&#32;{
561 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;reportError&#32;(<emphasis role="stringliteral">&quot;ERROR:&#32;this&#32;file&#32;has&#32;a&#32;bit&#32;depth&#32;that&#32;is&#32;not&#32;8,&#32;16,&#32;24&#32;or&#32;32&#32;bits&quot;</emphasis>);
562 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keywordflow">return</emphasis>&#32;<emphasis role="keyword">false</emphasis>;
563 &#32;&#32;&#32;&#32;}
564 &#32;&#32;&#32;&#32;
565 &#32;&#32;&#32;&#32;<emphasis role="comment">//&#32;-----------------------------------------------------------</emphasis>
566 &#32;&#32;&#32;&#32;<emphasis role="comment">//&#32;DATA&#32;CHUNK</emphasis>
567 &#32;&#32;&#32;&#32;<emphasis role="keywordtype">int</emphasis>&#32;d&#32;=&#32;indexOfDataChunk;
568 &#32;&#32;&#32;&#32;std::string&#32;dataChunkID&#32;(fileData.begin()&#32;+&#32;d,&#32;fileData.begin()&#32;+&#32;d&#32;+&#32;4);
569 &#32;&#32;&#32;&#32;int32_t&#32;dataChunkSize&#32;=&#32;fourBytesToInt&#32;(fileData,&#32;d&#32;+&#32;4);
570 &#32;&#32;&#32;&#32;
571 &#32;&#32;&#32;&#32;<emphasis role="keywordtype">int</emphasis>&#32;numSamples&#32;=&#32;dataChunkSize&#32;/&#32;(<link linkend="_namespacemake_headers_1aebae91248540ba01faf787f19070a220">numChannels</link>&#32;*&#32;<link linkend="_namespaceaiff__stereo__16bit__44100_1a9437286c09cbbda5f152c5a5e231eda5">bitDepth</link>&#32;/&#32;8);
572 &#32;&#32;&#32;&#32;<emphasis role="keywordtype">int</emphasis>&#32;samplesStartIndex&#32;=&#32;indexOfDataChunk&#32;+&#32;8;
573 &#32;&#32;&#32;&#32;
574 &#32;&#32;&#32;&#32;clearAudioBuffer();
575 &#32;&#32;&#32;&#32;samples.resize&#32;(<link linkend="_namespacemake_headers_1aebae91248540ba01faf787f19070a220">numChannels</link>);
576 &#32;&#32;&#32;&#32;
577 &#32;&#32;&#32;&#32;<emphasis role="keywordflow">for</emphasis>&#32;(<emphasis role="keywordtype">int</emphasis>&#32;i&#32;=&#32;0;&#32;i&#32;&lt;&#32;numSamples;&#32;i++)
578 &#32;&#32;&#32;&#32;{
579 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keywordflow">for</emphasis>&#32;(<emphasis role="keywordtype">int</emphasis>&#32;channel&#32;=&#32;0;&#32;channel&#32;&lt;&#32;<link linkend="_namespacemake_headers_1aebae91248540ba01faf787f19070a220">numChannels</link>;&#32;channel++)
580 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;{
581 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keywordtype">int</emphasis>&#32;sampleIndex&#32;=&#32;samplesStartIndex&#32;+&#32;(numBytesPerBlock&#32;*&#32;i)&#32;+&#32;channel&#32;*&#32;numBytesPerSample;
582 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;
583 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keywordflow">if</emphasis>&#32;((sampleIndex&#32;+&#32;(<link linkend="_namespaceaiff__stereo__16bit__44100_1a9437286c09cbbda5f152c5a5e231eda5">bitDepth</link>&#32;/&#32;8)&#32;-&#32;1)&#32;&gt;=&#32;fileData.size())
584 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;{
585 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;reportError&#32;(<emphasis role="stringliteral">&quot;ERROR:&#32;read&#32;file&#32;error&#32;as&#32;the&#32;metadata&#32;indicates&#32;more&#32;samples&#32;than&#32;there&#32;are&#32;in&#32;the&#32;file&#32;data&quot;</emphasis>);
586 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keywordflow">return</emphasis>&#32;<emphasis role="keyword">false</emphasis>;
587 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;}
588 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;
589 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keywordflow">if</emphasis>&#32;(<link linkend="_namespaceaiff__stereo__16bit__44100_1a9437286c09cbbda5f152c5a5e231eda5">bitDepth</link>&#32;==&#32;8)
590 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;{
591 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;T&#32;sample&#32;=&#32;singleByteToSample&#32;(fileData[sampleIndex]);
592 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;samples[channel].push_back&#32;(sample);
593 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;}
594 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keywordflow">else</emphasis>&#32;<emphasis role="keywordflow">if</emphasis>&#32;(<link linkend="_namespaceaiff__stereo__16bit__44100_1a9437286c09cbbda5f152c5a5e231eda5">bitDepth</link>&#32;==&#32;16)
595 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;{
596 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;int16_t&#32;sampleAsInt&#32;=&#32;twoBytesToInt&#32;(fileData,&#32;sampleIndex);
597 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;T&#32;sample&#32;=&#32;sixteenBitIntToSample&#32;(sampleAsInt);
598 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;samples[channel].push_back&#32;(sample);
599 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;}
600 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keywordflow">else</emphasis>&#32;<emphasis role="keywordflow">if</emphasis>&#32;(<link linkend="_namespaceaiff__stereo__16bit__44100_1a9437286c09cbbda5f152c5a5e231eda5">bitDepth</link>&#32;==&#32;24)
601 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;{
602 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;int32_t&#32;sampleAsInt&#32;=&#32;0;
603 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;sampleAsInt&#32;=&#32;(fileData[sampleIndex&#32;+&#32;2]&#32;&lt;&lt;&#32;16)&#32;|&#32;(fileData[sampleIndex&#32;+&#32;1]&#32;&lt;&lt;&#32;8)&#32;|&#32;fileData[sampleIndex];
604 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;
605 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keywordflow">if</emphasis>&#32;(sampleAsInt&#32;&amp;&#32;0x800000)&#32;<emphasis role="comment">//&#32;&#32;if&#32;the&#32;24th&#32;bit&#32;is&#32;set,&#32;this&#32;is&#32;a&#32;negative&#32;number&#32;in&#32;24-bit&#32;world</emphasis>
606 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;sampleAsInt&#32;=&#32;sampleAsInt&#32;|&#32;~0xFFFFFF;&#32;<emphasis role="comment">//&#32;so&#32;make&#32;sure&#32;sign&#32;is&#32;extended&#32;to&#32;the&#32;32&#32;bit&#32;float</emphasis>
607 
608 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;T&#32;sample&#32;=&#32;(T)sampleAsInt&#32;/&#32;(T)8388608.;
609 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;samples[channel].push_back&#32;(sample);
610 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;}
611 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keywordflow">else</emphasis>&#32;<emphasis role="keywordflow">if</emphasis>&#32;(<link linkend="_namespaceaiff__stereo__16bit__44100_1a9437286c09cbbda5f152c5a5e231eda5">bitDepth</link>&#32;==&#32;32)
612 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;{
613 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;int32_t&#32;sampleAsInt&#32;=&#32;fourBytesToInt&#32;(fileData,&#32;sampleIndex);
614 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;T&#32;sample;
615 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;
616 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keywordflow">if</emphasis>&#32;(audioFormat&#32;==&#32;<link linkend="__audio_file_8h_1a24ed57f869bfefdef1bed0a033886d8eaf48e2c55df672bab9d55c60af50a7181">WavAudioFormat::IEEEFloat</link>)
617 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;sample&#32;=&#32;(T)<emphasis role="keyword">reinterpret_cast&lt;</emphasis><emphasis role="keywordtype">float</emphasis>&amp;<emphasis role="keyword">&gt;</emphasis>&#32;(sampleAsInt);
618 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keywordflow">else</emphasis>&#32;<emphasis role="comment">//&#32;assume&#32;PCM</emphasis>
619 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;sample&#32;=&#32;(T)&#32;sampleAsInt&#32;/&#32;<emphasis role="keyword">static_cast&lt;</emphasis><emphasis role="keywordtype">float</emphasis><emphasis role="keyword">&gt;</emphasis>&#32;(std::numeric_limits&lt;std::int32_t&gt;::max());
620 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;
621 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;samples[channel].push_back&#32;(sample);
622 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;}
623 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keywordflow">else</emphasis>
624 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;{
625 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;assert&#32;(<emphasis role="keyword">false</emphasis>);
626 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;}
627 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;}
628 &#32;&#32;&#32;&#32;}
629 
630 &#32;&#32;&#32;&#32;<emphasis role="comment">//&#32;-----------------------------------------------------------</emphasis>
631 &#32;&#32;&#32;&#32;<emphasis role="comment">//&#32;iXML&#32;CHUNK</emphasis>
632 &#32;&#32;&#32;&#32;<emphasis role="keywordflow">if</emphasis>&#32;(indexOfXMLChunk&#32;!=&#32;-1)
633 &#32;&#32;&#32;&#32;{
634 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;int32_t&#32;chunkSize&#32;=&#32;fourBytesToInt&#32;(fileData,&#32;indexOfXMLChunk&#32;+&#32;4);
635 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;iXMLChunk&#32;=&#32;std::string&#32;((<emphasis role="keyword">const</emphasis>&#32;<emphasis role="keywordtype">char</emphasis>*)&#32;&amp;fileData[indexOfXMLChunk&#32;+&#32;8],&#32;chunkSize);
636 &#32;&#32;&#32;&#32;}
637 
638 &#32;&#32;&#32;&#32;<emphasis role="keywordflow">return</emphasis>&#32;<emphasis role="keyword">true</emphasis>;
639 }
640 
641 <emphasis role="comment">//=============================================================</emphasis>
642 <emphasis role="keyword">template</emphasis>&#32;&lt;<emphasis role="keyword">class</emphasis>&#32;T&gt;
643 <emphasis role="keywordtype">bool</emphasis>&#32;<link linkend="_class_audio_file">AudioFile&lt;T&gt;::decodeAiffFile</link>&#32;(std::vector&lt;uint8_t&gt;&amp;&#32;fileData)
644 {
645 &#32;&#32;&#32;&#32;<emphasis role="comment">//&#32;-----------------------------------------------------------</emphasis>
646 &#32;&#32;&#32;&#32;<emphasis role="comment">//&#32;HEADER&#32;CHUNK</emphasis>
647 &#32;&#32;&#32;&#32;std::string&#32;headerChunkID&#32;(fileData.begin(),&#32;fileData.begin()&#32;+&#32;4);
648 &#32;&#32;&#32;&#32;<emphasis role="comment">//int32_t&#32;fileSizeInBytes&#32;=&#32;fourBytesToInt&#32;(fileData,&#32;4,&#32;Endianness::BigEndian)&#32;+&#32;8;</emphasis>
649 &#32;&#32;&#32;&#32;std::string&#32;format&#32;(fileData.begin()&#32;+&#32;8,&#32;fileData.begin()&#32;+&#32;12);
650 &#32;&#32;&#32;&#32;
651 &#32;&#32;&#32;&#32;<emphasis role="keywordtype">int</emphasis>&#32;audioFormat&#32;=&#32;format&#32;==&#32;<emphasis role="stringliteral">&quot;AIFF&quot;</emphasis>&#32;?&#32;<link linkend="__audio_file_8h_1a526ed66f20752002a63ee72e2e350d7da8ff322ff580065823204d6a61d90f9b3">AIFFAudioFormat::Uncompressed</link>&#32;:&#32;format&#32;==&#32;<emphasis role="stringliteral">&quot;AIFC&quot;</emphasis>&#32;?&#32;<link linkend="__audio_file_8h_1a526ed66f20752002a63ee72e2e350d7da4e27fd9489beea00d95846abc48ab83e">AIFFAudioFormat::Compressed</link>&#32;:&#32;<link linkend="__audio_file_8h_1a526ed66f20752002a63ee72e2e350d7da4dfd42ec49d09d8c6555c218301cc30f">AIFFAudioFormat::Error</link>;
652 &#32;&#32;&#32;&#32;
653 &#32;&#32;&#32;&#32;<emphasis role="comment">//&#32;-----------------------------------------------------------</emphasis>
654 &#32;&#32;&#32;&#32;<emphasis role="comment">//&#32;try&#32;and&#32;find&#32;the&#32;start&#32;points&#32;of&#32;key&#32;chunks</emphasis>
655 &#32;&#32;&#32;&#32;<emphasis role="keywordtype">int</emphasis>&#32;indexOfCommChunk&#32;=&#32;getIndexOfChunk&#32;(fileData,&#32;<emphasis role="stringliteral">&quot;COMM&quot;</emphasis>,&#32;12,&#32;Endianness::BigEndian);
656 &#32;&#32;&#32;&#32;<emphasis role="keywordtype">int</emphasis>&#32;indexOfSoundDataChunk&#32;=&#32;getIndexOfChunk&#32;(fileData,&#32;<emphasis role="stringliteral">&quot;SSND&quot;</emphasis>,&#32;12,&#32;Endianness::BigEndian);
657 &#32;&#32;&#32;&#32;<emphasis role="keywordtype">int</emphasis>&#32;indexOfXMLChunk&#32;=&#32;getIndexOfChunk&#32;(fileData,&#32;<emphasis role="stringliteral">&quot;iXML&quot;</emphasis>,&#32;12,&#32;Endianness::BigEndian);
658 &#32;&#32;&#32;&#32;
659 &#32;&#32;&#32;&#32;<emphasis role="comment">//&#32;if&#32;we&#32;can&apos;t&#32;find&#32;the&#32;data&#32;or&#32;format&#32;chunks,&#32;or&#32;the&#32;IDs/formats&#32;don&apos;t&#32;seem&#32;to&#32;be&#32;as&#32;expected</emphasis>
660 &#32;&#32;&#32;&#32;<emphasis role="comment">//&#32;then&#32;it&#32;is&#32;unlikely&#32;we&apos;ll&#32;able&#32;to&#32;read&#32;this&#32;file,&#32;so&#32;abort</emphasis>
661 &#32;&#32;&#32;&#32;<emphasis role="keywordflow">if</emphasis>&#32;(indexOfSoundDataChunk&#32;==&#32;-1&#32;||&#32;indexOfCommChunk&#32;==&#32;-1&#32;||&#32;headerChunkID&#32;!=&#32;<emphasis role="stringliteral">&quot;FORM&quot;</emphasis>&#32;||&#32;audioFormat&#32;==&#32;<link linkend="__audio_file_8h_1a526ed66f20752002a63ee72e2e350d7da4dfd42ec49d09d8c6555c218301cc30f">AIFFAudioFormat::Error</link>)
662 &#32;&#32;&#32;&#32;{
663 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;reportError&#32;(<emphasis role="stringliteral">&quot;ERROR:&#32;this&#32;doesn&apos;t&#32;seem&#32;to&#32;be&#32;a&#32;valid&#32;AIFF&#32;file&quot;</emphasis>);
664 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keywordflow">return</emphasis>&#32;<emphasis role="keyword">false</emphasis>;
665 &#32;&#32;&#32;&#32;}
666 
667 &#32;&#32;&#32;&#32;<emphasis role="comment">//&#32;-----------------------------------------------------------</emphasis>
668 &#32;&#32;&#32;&#32;<emphasis role="comment">//&#32;COMM&#32;CHUNK</emphasis>
669 &#32;&#32;&#32;&#32;<emphasis role="keywordtype">int</emphasis>&#32;p&#32;=&#32;indexOfCommChunk;
670 &#32;&#32;&#32;&#32;std::string&#32;commChunkID&#32;(fileData.begin()&#32;+&#32;p,&#32;fileData.begin()&#32;+&#32;p&#32;+&#32;4);
671 &#32;&#32;&#32;&#32;<emphasis role="comment">//int32_t&#32;commChunkSize&#32;=&#32;fourBytesToInt&#32;(fileData,&#32;p&#32;+&#32;4,&#32;Endianness::BigEndian);</emphasis>
672 &#32;&#32;&#32;&#32;int16_t&#32;<link linkend="_namespacemake_headers_1aebae91248540ba01faf787f19070a220">numChannels</link>&#32;=&#32;twoBytesToInt&#32;(fileData,&#32;p&#32;+&#32;8,&#32;Endianness::BigEndian);
673 &#32;&#32;&#32;&#32;int32_t&#32;<link linkend="_namespaceaiff__stereo__16bit__44100_1aaf05006025852ebe33ea51dbb9d4dac2">numSamplesPerChannel</link>&#32;=&#32;fourBytesToInt&#32;(fileData,&#32;p&#32;+&#32;10,&#32;Endianness::BigEndian);
674 &#32;&#32;&#32;&#32;<link linkend="_namespaceaiff__stereo__16bit__44100_1a9437286c09cbbda5f152c5a5e231eda5">bitDepth</link>&#32;=&#32;(int)&#32;twoBytesToInt&#32;(fileData,&#32;p&#32;+&#32;14,&#32;Endianness::BigEndian);
675 &#32;&#32;&#32;&#32;<link linkend="_namespaceaiff__stereo__16bit__44100_1a495b7a67f7fb515c0a5df8139c44e8c4">sampleRate</link>&#32;=&#32;getAiffSampleRate&#32;(fileData,&#32;p&#32;+&#32;16);
676 &#32;&#32;&#32;&#32;
677 &#32;&#32;&#32;&#32;<emphasis role="comment">//&#32;check&#32;the&#32;sample&#32;rate&#32;was&#32;properly&#32;decoded</emphasis>
678 &#32;&#32;&#32;&#32;<emphasis role="keywordflow">if</emphasis>&#32;(<link linkend="_namespaceaiff__stereo__16bit__44100_1a495b7a67f7fb515c0a5df8139c44e8c4">sampleRate</link>&#32;==&#32;0)
679 &#32;&#32;&#32;&#32;{
680 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;reportError&#32;(<emphasis role="stringliteral">&quot;ERROR:&#32;this&#32;AIFF&#32;file&#32;has&#32;an&#32;unsupported&#32;sample&#32;rate&quot;</emphasis>);
681 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keywordflow">return</emphasis>&#32;<emphasis role="keyword">false</emphasis>;
682 &#32;&#32;&#32;&#32;}
683 &#32;&#32;&#32;&#32;
684 &#32;&#32;&#32;&#32;<emphasis role="comment">//&#32;check&#32;the&#32;number&#32;of&#32;channels&#32;is&#32;mono&#32;or&#32;stereo</emphasis>
685 &#32;&#32;&#32;&#32;<emphasis role="keywordflow">if</emphasis>&#32;(numChannels&#32;&lt;&#32;1&#32;||numChannels&#32;&gt;&#32;2)
686 &#32;&#32;&#32;&#32;{
687 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;reportError&#32;(<emphasis role="stringliteral">&quot;ERROR:&#32;this&#32;AIFF&#32;file&#32;seems&#32;to&#32;be&#32;neither&#32;mono&#32;nor&#32;stereo&#32;(perhaps&#32;multi-track,&#32;or&#32;corrupted?)&quot;</emphasis>);
688 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keywordflow">return</emphasis>&#32;<emphasis role="keyword">false</emphasis>;
689 &#32;&#32;&#32;&#32;}
690 &#32;&#32;&#32;&#32;
691 &#32;&#32;&#32;&#32;<emphasis role="comment">//&#32;check&#32;bit&#32;depth&#32;is&#32;either&#32;8,&#32;16,&#32;24&#32;or&#32;32-bit</emphasis>
692 &#32;&#32;&#32;&#32;<emphasis role="keywordflow">if</emphasis>&#32;(<link linkend="_namespaceaiff__stereo__16bit__44100_1a9437286c09cbbda5f152c5a5e231eda5">bitDepth</link>&#32;!=&#32;8&#32;&amp;&amp;&#32;<link linkend="_namespaceaiff__stereo__16bit__44100_1a9437286c09cbbda5f152c5a5e231eda5">bitDepth</link>&#32;!=&#32;16&#32;&amp;&amp;&#32;<link linkend="_namespaceaiff__stereo__16bit__44100_1a9437286c09cbbda5f152c5a5e231eda5">bitDepth</link>&#32;!=&#32;24&#32;&amp;&amp;&#32;<link linkend="_namespaceaiff__stereo__16bit__44100_1a9437286c09cbbda5f152c5a5e231eda5">bitDepth</link>&#32;!=&#32;32)
693 &#32;&#32;&#32;&#32;{
694 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;reportError&#32;(<emphasis role="stringliteral">&quot;ERROR:&#32;this&#32;file&#32;has&#32;a&#32;bit&#32;depth&#32;that&#32;is&#32;not&#32;8,&#32;16,&#32;24&#32;or&#32;32&#32;bits&quot;</emphasis>);
695 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keywordflow">return</emphasis>&#32;<emphasis role="keyword">false</emphasis>;
696 &#32;&#32;&#32;&#32;}
697 &#32;&#32;&#32;&#32;
698 &#32;&#32;&#32;&#32;<emphasis role="comment">//&#32;-----------------------------------------------------------</emphasis>
699 &#32;&#32;&#32;&#32;<emphasis role="comment">//&#32;SSND&#32;CHUNK</emphasis>
700 &#32;&#32;&#32;&#32;<emphasis role="keywordtype">int</emphasis>&#32;s&#32;=&#32;indexOfSoundDataChunk;
701 &#32;&#32;&#32;&#32;std::string&#32;soundDataChunkID&#32;(fileData.begin()&#32;+&#32;s,&#32;fileData.begin()&#32;+&#32;s&#32;+&#32;4);
702 &#32;&#32;&#32;&#32;int32_t&#32;soundDataChunkSize&#32;=&#32;fourBytesToInt&#32;(fileData,&#32;s&#32;+&#32;4,&#32;Endianness::BigEndian);
703 &#32;&#32;&#32;&#32;int32_t&#32;offset&#32;=&#32;fourBytesToInt&#32;(fileData,&#32;s&#32;+&#32;8,&#32;Endianness::BigEndian);
704 &#32;&#32;&#32;&#32;<emphasis role="comment">//int32_t&#32;blockSize&#32;=&#32;fourBytesToInt&#32;(fileData,&#32;s&#32;+&#32;12,&#32;Endianness::BigEndian);</emphasis>
705 &#32;&#32;&#32;&#32;
706 &#32;&#32;&#32;&#32;<emphasis role="keywordtype">int</emphasis>&#32;numBytesPerSample&#32;=&#32;<link linkend="_namespaceaiff__stereo__16bit__44100_1a9437286c09cbbda5f152c5a5e231eda5">bitDepth</link>&#32;/&#32;8;
707 &#32;&#32;&#32;&#32;<emphasis role="keywordtype">int</emphasis>&#32;numBytesPerFrame&#32;=&#32;numBytesPerSample&#32;*&#32;<link linkend="_namespacemake_headers_1aebae91248540ba01faf787f19070a220">numChannels</link>;
708 &#32;&#32;&#32;&#32;<emphasis role="keywordtype">int</emphasis>&#32;totalNumAudioSampleBytes&#32;=&#32;<link linkend="_namespaceaiff__stereo__16bit__44100_1aaf05006025852ebe33ea51dbb9d4dac2">numSamplesPerChannel</link>&#32;*&#32;numBytesPerFrame;
709 &#32;&#32;&#32;&#32;<emphasis role="keywordtype">int</emphasis>&#32;samplesStartIndex&#32;=&#32;s&#32;+&#32;16&#32;+&#32;(int)offset;
710 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;
711 &#32;&#32;&#32;&#32;<emphasis role="comment">//&#32;sanity&#32;check&#32;the&#32;data</emphasis>
712 &#32;&#32;&#32;&#32;<emphasis role="keywordflow">if</emphasis>&#32;((soundDataChunkSize&#32;-&#32;8)&#32;!=&#32;totalNumAudioSampleBytes&#32;||&#32;totalNumAudioSampleBytes&#32;&gt;&#32;<emphasis role="keyword">static_cast&lt;</emphasis><emphasis role="keywordtype">long</emphasis><emphasis role="keyword">&gt;</emphasis>(fileData.size()&#32;-&#32;samplesStartIndex))
713 &#32;&#32;&#32;&#32;{
714 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;reportError&#32;(<emphasis role="stringliteral">&quot;ERROR:&#32;the&#32;metadatafor&#32;this&#32;file&#32;doesn&apos;t&#32;seem&#32;right&quot;</emphasis>);
715 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keywordflow">return</emphasis>&#32;<emphasis role="keyword">false</emphasis>;
716 &#32;&#32;&#32;&#32;}
717 &#32;&#32;&#32;&#32;
718 &#32;&#32;&#32;&#32;clearAudioBuffer();
719 &#32;&#32;&#32;&#32;samples.resize&#32;(<link linkend="_namespacemake_headers_1aebae91248540ba01faf787f19070a220">numChannels</link>);
720 &#32;&#32;&#32;&#32;
721 &#32;&#32;&#32;&#32;<emphasis role="keywordflow">for</emphasis>&#32;(<emphasis role="keywordtype">int</emphasis>&#32;i&#32;=&#32;0;&#32;i&#32;&lt;&#32;<link linkend="_namespaceaiff__stereo__16bit__44100_1aaf05006025852ebe33ea51dbb9d4dac2">numSamplesPerChannel</link>;&#32;i++)
722 &#32;&#32;&#32;&#32;{
723 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keywordflow">for</emphasis>&#32;(<emphasis role="keywordtype">int</emphasis>&#32;channel&#32;=&#32;0;&#32;channel&#32;&lt;&#32;<link linkend="_namespacemake_headers_1aebae91248540ba01faf787f19070a220">numChannels</link>;&#32;channel++)
724 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;{
725 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keywordtype">int</emphasis>&#32;sampleIndex&#32;=&#32;samplesStartIndex&#32;+&#32;(numBytesPerFrame&#32;*&#32;i)&#32;+&#32;channel&#32;*&#32;numBytesPerSample;
726 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;
727 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keywordflow">if</emphasis>&#32;((sampleIndex&#32;+&#32;(<link linkend="_namespaceaiff__stereo__16bit__44100_1a9437286c09cbbda5f152c5a5e231eda5">bitDepth</link>&#32;/&#32;8)&#32;-&#32;1)&#32;&gt;=&#32;fileData.size())
728 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;{
729 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;reportError&#32;(<emphasis role="stringliteral">&quot;ERROR:&#32;read&#32;file&#32;error&#32;as&#32;the&#32;metadata&#32;indicates&#32;more&#32;samples&#32;than&#32;there&#32;are&#32;in&#32;the&#32;file&#32;data&quot;</emphasis>);
730 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keywordflow">return</emphasis>&#32;<emphasis role="keyword">false</emphasis>;
731 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;}
732 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;
733 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keywordflow">if</emphasis>&#32;(<link linkend="_namespaceaiff__stereo__16bit__44100_1a9437286c09cbbda5f152c5a5e231eda5">bitDepth</link>&#32;==&#32;8)
734 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;{
735 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;int8_t&#32;sampleAsSigned8Bit&#32;=&#32;(int8_t)fileData[sampleIndex];
736 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;T&#32;sample&#32;=&#32;(T)sampleAsSigned8Bit&#32;/&#32;(T)128.;
737 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;samples[channel].push_back&#32;(sample);
738 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;}
739 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keywordflow">else</emphasis>&#32;<emphasis role="keywordflow">if</emphasis>&#32;(<link linkend="_namespaceaiff__stereo__16bit__44100_1a9437286c09cbbda5f152c5a5e231eda5">bitDepth</link>&#32;==&#32;16)
740 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;{
741 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;int16_t&#32;sampleAsInt&#32;=&#32;twoBytesToInt&#32;(fileData,&#32;sampleIndex,&#32;Endianness::BigEndian);
742 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;T&#32;sample&#32;=&#32;sixteenBitIntToSample&#32;(sampleAsInt);
743 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;samples[channel].push_back&#32;(sample);
744 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;}
745 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keywordflow">else</emphasis>&#32;<emphasis role="keywordflow">if</emphasis>&#32;(<link linkend="_namespaceaiff__stereo__16bit__44100_1a9437286c09cbbda5f152c5a5e231eda5">bitDepth</link>&#32;==&#32;24)
746 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;{
747 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;int32_t&#32;sampleAsInt&#32;=&#32;0;
748 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;sampleAsInt&#32;=&#32;(fileData[sampleIndex]&#32;&lt;&lt;&#32;16)&#32;|&#32;(fileData[sampleIndex&#32;+&#32;1]&#32;&lt;&lt;&#32;8)&#32;|&#32;fileData[sampleIndex&#32;+&#32;2];
749 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;
750 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keywordflow">if</emphasis>&#32;(sampleAsInt&#32;&amp;&#32;0x800000)&#32;<emphasis role="comment">//&#32;&#32;if&#32;the&#32;24th&#32;bit&#32;is&#32;set,&#32;this&#32;is&#32;a&#32;negative&#32;number&#32;in&#32;24-bit&#32;world</emphasis>
751 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;sampleAsInt&#32;=&#32;sampleAsInt&#32;|&#32;~0xFFFFFF;&#32;<emphasis role="comment">//&#32;so&#32;make&#32;sure&#32;sign&#32;is&#32;extended&#32;to&#32;the&#32;32&#32;bit&#32;float</emphasis>
752 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;
753 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;T&#32;sample&#32;=&#32;(T)sampleAsInt&#32;/&#32;(T)8388608.;
754 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;samples[channel].push_back&#32;(sample);
755 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;}
756 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keywordflow">else</emphasis>&#32;<emphasis role="keywordflow">if</emphasis>&#32;(<link linkend="_namespaceaiff__stereo__16bit__44100_1a9437286c09cbbda5f152c5a5e231eda5">bitDepth</link>&#32;==&#32;32)
757 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;{
758 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;int32_t&#32;sampleAsInt&#32;=&#32;fourBytesToInt&#32;(fileData,&#32;sampleIndex,&#32;Endianness::BigEndian);
759 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;T&#32;sample;
760 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;
761 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keywordflow">if</emphasis>&#32;(audioFormat&#32;==&#32;<link linkend="__audio_file_8h_1a526ed66f20752002a63ee72e2e350d7da4e27fd9489beea00d95846abc48ab83e">AIFFAudioFormat::Compressed</link>)
762 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;sample&#32;=&#32;(T)<emphasis role="keyword">reinterpret_cast&lt;</emphasis><emphasis role="keywordtype">float</emphasis>&amp;<emphasis role="keyword">&gt;</emphasis>&#32;(sampleAsInt);
763 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keywordflow">else</emphasis>&#32;<emphasis role="comment">//&#32;assume&#32;uncompressed</emphasis>
764 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;sample&#32;=&#32;(T)&#32;sampleAsInt&#32;/&#32;<emphasis role="keyword">static_cast&lt;</emphasis><emphasis role="keywordtype">float</emphasis><emphasis role="keyword">&gt;</emphasis>&#32;(std::numeric_limits&lt;std::int32_t&gt;::max());
765 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;
766 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;samples[channel].push_back&#32;(sample);
767 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;}
768 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keywordflow">else</emphasis>
769 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;{
770 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;assert&#32;(<emphasis role="keyword">false</emphasis>);
771 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;}
772 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;}
773 &#32;&#32;&#32;&#32;}
774 
775 &#32;&#32;&#32;&#32;<emphasis role="comment">//&#32;-----------------------------------------------------------</emphasis>
776 &#32;&#32;&#32;&#32;<emphasis role="comment">//&#32;iXML&#32;CHUNK</emphasis>
777 &#32;&#32;&#32;&#32;<emphasis role="keywordflow">if</emphasis>&#32;(indexOfXMLChunk&#32;!=&#32;-1)
778 &#32;&#32;&#32;&#32;{
779 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;int32_t&#32;chunkSize&#32;=&#32;fourBytesToInt&#32;(fileData,&#32;indexOfXMLChunk&#32;+&#32;4);
780 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;iXMLChunk&#32;=&#32;std::string&#32;((<emphasis role="keyword">const</emphasis>&#32;<emphasis role="keywordtype">char</emphasis>*)&#32;&amp;fileData[indexOfXMLChunk&#32;+&#32;8],&#32;chunkSize);
781 &#32;&#32;&#32;&#32;}
782 &#32;&#32;&#32;&#32;
783 &#32;&#32;&#32;&#32;<emphasis role="keywordflow">return</emphasis>&#32;<emphasis role="keyword">true</emphasis>;
784 }
785 
786 <emphasis role="comment">//=============================================================</emphasis>
787 <emphasis role="keyword">template</emphasis>&#32;&lt;<emphasis role="keyword">class</emphasis>&#32;T&gt;
788 uint32_t&#32;<link linkend="_class_audio_file">AudioFile&lt;T&gt;::getAiffSampleRate</link>&#32;(std::vector&lt;uint8_t&gt;&amp;&#32;fileData,&#32;<emphasis role="keywordtype">int</emphasis>&#32;sampleRateStartIndex)
789 {
790 &#32;&#32;&#32;&#32;<emphasis role="keywordflow">for</emphasis>&#32;(<emphasis role="keyword">auto</emphasis>&#32;it&#32;:&#32;aiffSampleRateTable)
791 &#32;&#32;&#32;&#32;{
792 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keywordflow">if</emphasis>&#32;(tenByteMatch&#32;(fileData,&#32;sampleRateStartIndex,&#32;it.second,&#32;0))
793 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keywordflow">return</emphasis>&#32;it.first;
794 &#32;&#32;&#32;&#32;}
795 &#32;&#32;&#32;&#32;
796 &#32;&#32;&#32;&#32;<emphasis role="keywordflow">return</emphasis>&#32;0;
797 }
798 
799 <emphasis role="comment">//=============================================================</emphasis>
800 <emphasis role="keyword">template</emphasis>&#32;&lt;<emphasis role="keyword">class</emphasis>&#32;T&gt;
801 <emphasis role="keywordtype">bool</emphasis>&#32;<link linkend="_class_audio_file">AudioFile&lt;T&gt;::tenByteMatch</link>&#32;(std::vector&lt;uint8_t&gt;&amp;&#32;v1,&#32;<emphasis role="keywordtype">int</emphasis>&#32;startIndex1,&#32;std::vector&lt;uint8_t&gt;&amp;&#32;v2,&#32;<emphasis role="keywordtype">int</emphasis>&#32;startIndex2)
802 {
803 &#32;&#32;&#32;&#32;<emphasis role="keywordflow">for</emphasis>&#32;(<emphasis role="keywordtype">int</emphasis>&#32;i&#32;=&#32;0;&#32;i&#32;&lt;&#32;10;&#32;i++)
804 &#32;&#32;&#32;&#32;{
805 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keywordflow">if</emphasis>&#32;(v1[startIndex1&#32;+&#32;i]&#32;!=&#32;v2[startIndex2&#32;+&#32;i])
806 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keywordflow">return</emphasis>&#32;<emphasis role="keyword">false</emphasis>;
807 &#32;&#32;&#32;&#32;}
808 &#32;&#32;&#32;&#32;
809 &#32;&#32;&#32;&#32;<emphasis role="keywordflow">return</emphasis>&#32;<emphasis role="keyword">true</emphasis>;
810 }
811 
812 <emphasis role="comment">//=============================================================</emphasis>
813 <emphasis role="keyword">template</emphasis>&#32;&lt;<emphasis role="keyword">class</emphasis>&#32;T&gt;
814 <emphasis role="keywordtype">void</emphasis>&#32;<link linkend="_class_audio_file">AudioFile&lt;T&gt;::addSampleRateToAiffData</link>&#32;(std::vector&lt;uint8_t&gt;&amp;&#32;fileData,&#32;uint32_t&#32;<link linkend="_namespaceaiff__stereo__16bit__44100_1a495b7a67f7fb515c0a5df8139c44e8c4">sampleRate</link>)
815 {
816 &#32;&#32;&#32;&#32;<emphasis role="keywordflow">if</emphasis>&#32;(aiffSampleRateTable.count&#32;(<link linkend="_namespaceaiff__stereo__16bit__44100_1a495b7a67f7fb515c0a5df8139c44e8c4">sampleRate</link>)&#32;&gt;&#32;0)
817 &#32;&#32;&#32;&#32;{
818 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keywordflow">for</emphasis>&#32;(<emphasis role="keywordtype">int</emphasis>&#32;i&#32;=&#32;0;&#32;i&#32;&lt;&#32;10;&#32;i++)
819 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;fileData.push_back&#32;(aiffSampleRateTable[<link linkend="_namespaceaiff__stereo__16bit__44100_1a495b7a67f7fb515c0a5df8139c44e8c4">sampleRate</link>][i]);
820 &#32;&#32;&#32;&#32;}
821 }
822 
823 <emphasis role="comment">//=============================================================</emphasis>
824 <emphasis role="keyword">template</emphasis>&#32;&lt;<emphasis role="keyword">class</emphasis>&#32;T&gt;
825 <emphasis role="keywordtype">bool</emphasis>&#32;<link linkend="_class_audio_file_1a415239cad5b54b4fef4a210ab79911e3">AudioFile&lt;T&gt;::save</link>&#32;(std::string&#32;filePath,&#32;<link linkend="__audio_file_8h_1ad18559d169602e85d0ad68da6ef8593f">AudioFileFormat</link>&#32;format)
826 {
827 &#32;&#32;&#32;&#32;<emphasis role="keywordflow">if</emphasis>&#32;(format&#32;==&#32;<link linkend="__audio_file_8h_1ad18559d169602e85d0ad68da6ef8593fad911b34823c7674c292556dc56148c27">AudioFileFormat::Wave</link>)
828 &#32;&#32;&#32;&#32;{
829 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keywordflow">return</emphasis>&#32;saveToWaveFile&#32;(filePath);
830 &#32;&#32;&#32;&#32;}
831 &#32;&#32;&#32;&#32;<emphasis role="keywordflow">else</emphasis>&#32;<emphasis role="keywordflow">if</emphasis>&#32;(format&#32;==&#32;<link linkend="__audio_file_8h_1ad18559d169602e85d0ad68da6ef8593fac2271ab764905d770a81d0920f8c6aaf">AudioFileFormat::Aiff</link>)
832 &#32;&#32;&#32;&#32;{
833 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keywordflow">return</emphasis>&#32;saveToAiffFile&#32;(filePath);
834 &#32;&#32;&#32;&#32;}
835 &#32;&#32;&#32;&#32;
836 &#32;&#32;&#32;&#32;<emphasis role="keywordflow">return</emphasis>&#32;<emphasis role="keyword">false</emphasis>;
837 }
838 
839 <emphasis role="comment">//=============================================================</emphasis>
840 <emphasis role="keyword">template</emphasis>&#32;&lt;<emphasis role="keyword">class</emphasis>&#32;T&gt;
841 <emphasis role="keywordtype">bool</emphasis>&#32;<link linkend="_class_audio_file">AudioFile&lt;T&gt;::saveToWaveFile</link>&#32;(std::string&#32;filePath)
842 {
843 &#32;&#32;&#32;&#32;std::vector&lt;uint8_t&gt;&#32;fileData;
844 &#32;&#32;&#32;&#32;
845 &#32;&#32;&#32;&#32;int32_t&#32;dataChunkSize&#32;=&#32;getNumSamplesPerChannel()&#32;*&#32;(getNumChannels()&#32;*&#32;<link linkend="_namespaceaiff__stereo__16bit__44100_1a9437286c09cbbda5f152c5a5e231eda5">bitDepth</link>&#32;/&#32;8);
846 &#32;&#32;&#32;&#32;int16_t&#32;audioFormat&#32;=&#32;<link linkend="_namespaceaiff__stereo__16bit__44100_1a9437286c09cbbda5f152c5a5e231eda5">bitDepth</link>&#32;==&#32;32&#32;?&#32;<link linkend="__audio_file_8h_1a24ed57f869bfefdef1bed0a033886d8eaf48e2c55df672bab9d55c60af50a7181">WavAudioFormat::IEEEFloat</link>&#32;:&#32;<link linkend="__audio_file_8h_1a24ed57f869bfefdef1bed0a033886d8ea91062305c293c8f87879282035b9e982">WavAudioFormat::PCM</link>;
847 &#32;&#32;&#32;&#32;int32_t&#32;formatChunkSize&#32;=&#32;audioFormat&#32;==&#32;<link linkend="__audio_file_8h_1a24ed57f869bfefdef1bed0a033886d8ea91062305c293c8f87879282035b9e982">WavAudioFormat::PCM</link>&#32;?&#32;16&#32;:&#32;18;
848 &#32;&#32;&#32;&#32;int32_t&#32;iXMLChunkSize&#32;=&#32;<emphasis role="keyword">static_cast&lt;</emphasis>int32_t<emphasis role="keyword">&gt;</emphasis>&#32;(iXMLChunk.size());
849 &#32;&#32;&#32;&#32;
850 &#32;&#32;&#32;&#32;<emphasis role="comment">//&#32;-----------------------------------------------------------</emphasis>
851 &#32;&#32;&#32;&#32;<emphasis role="comment">//&#32;HEADER&#32;CHUNK</emphasis>
852 &#32;&#32;&#32;&#32;addStringToFileData&#32;(fileData,&#32;<emphasis role="stringliteral">&quot;RIFF&quot;</emphasis>);
853 &#32;&#32;&#32;&#32;
854 &#32;&#32;&#32;&#32;<emphasis role="comment">//&#32;The&#32;file&#32;size&#32;in&#32;bytes&#32;is&#32;the&#32;header&#32;chunk&#32;size&#32;(4,&#32;not&#32;counting&#32;RIFF&#32;and&#32;WAVE)&#32;+&#32;the&#32;format</emphasis>
855 &#32;&#32;&#32;&#32;<emphasis role="comment">//&#32;chunk&#32;size&#32;(24)&#32;+&#32;the&#32;metadata&#32;part&#32;of&#32;the&#32;data&#32;chunk&#32;plus&#32;the&#32;actual&#32;data&#32;chunk&#32;size</emphasis>
856 &#32;&#32;&#32;&#32;int32_t&#32;fileSizeInBytes&#32;=&#32;4&#32;+&#32;formatChunkSize&#32;+&#32;8&#32;+&#32;8&#32;+&#32;dataChunkSize;
857 &#32;&#32;&#32;&#32;<emphasis role="keywordflow">if</emphasis>&#32;(iXMLChunkSize&#32;&gt;&#32;0)
858 &#32;&#32;&#32;&#32;{
859 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;fileSizeInBytes&#32;+=&#32;(8&#32;+&#32;iXMLChunkSize);
860 &#32;&#32;&#32;&#32;}
861 
862 &#32;&#32;&#32;&#32;addInt32ToFileData&#32;(fileData,&#32;fileSizeInBytes);
863 &#32;&#32;&#32;&#32;
864 &#32;&#32;&#32;&#32;addStringToFileData&#32;(fileData,&#32;<emphasis role="stringliteral">&quot;WAVE&quot;</emphasis>);
865 &#32;&#32;&#32;&#32;
866 &#32;&#32;&#32;&#32;<emphasis role="comment">//&#32;-----------------------------------------------------------</emphasis>
867 &#32;&#32;&#32;&#32;<emphasis role="comment">//&#32;FORMAT&#32;CHUNK</emphasis>
868 &#32;&#32;&#32;&#32;addStringToFileData&#32;(fileData,&#32;<emphasis role="stringliteral">&quot;fmt&#32;&quot;</emphasis>);
869 &#32;&#32;&#32;&#32;addInt32ToFileData&#32;(fileData,&#32;formatChunkSize);&#32;<emphasis role="comment">//&#32;format&#32;chunk&#32;size&#32;(16&#32;for&#32;PCM)</emphasis>
870 &#32;&#32;&#32;&#32;addInt16ToFileData&#32;(fileData,&#32;audioFormat);&#32;<emphasis role="comment">//&#32;audio&#32;format</emphasis>
871 &#32;&#32;&#32;&#32;addInt16ToFileData&#32;(fileData,&#32;(int16_t)getNumChannels());&#32;<emphasis role="comment">//&#32;num&#32;channels</emphasis>
872 &#32;&#32;&#32;&#32;addInt32ToFileData&#32;(fileData,&#32;(int32_t)<link linkend="_namespaceaiff__stereo__16bit__44100_1a495b7a67f7fb515c0a5df8139c44e8c4">sampleRate</link>);&#32;<emphasis role="comment">//&#32;sample&#32;rate</emphasis>
873 &#32;&#32;&#32;&#32;
874 &#32;&#32;&#32;&#32;int32_t&#32;numBytesPerSecond&#32;=&#32;(int32_t)&#32;((getNumChannels()&#32;*&#32;<link linkend="_namespaceaiff__stereo__16bit__44100_1a495b7a67f7fb515c0a5df8139c44e8c4">sampleRate</link>&#32;*&#32;<link linkend="_namespaceaiff__stereo__16bit__44100_1a9437286c09cbbda5f152c5a5e231eda5">bitDepth</link>)&#32;/&#32;8);
875 &#32;&#32;&#32;&#32;addInt32ToFileData&#32;(fileData,&#32;numBytesPerSecond);
876 &#32;&#32;&#32;&#32;
877 &#32;&#32;&#32;&#32;int16_t&#32;numBytesPerBlock&#32;=&#32;getNumChannels()&#32;*&#32;(<link linkend="_namespaceaiff__stereo__16bit__44100_1a9437286c09cbbda5f152c5a5e231eda5">bitDepth</link>&#32;/&#32;8);
878 &#32;&#32;&#32;&#32;addInt16ToFileData&#32;(fileData,&#32;numBytesPerBlock);
879 &#32;&#32;&#32;&#32;
880 &#32;&#32;&#32;&#32;addInt16ToFileData&#32;(fileData,&#32;(int16_t)<link linkend="_namespaceaiff__stereo__16bit__44100_1a9437286c09cbbda5f152c5a5e231eda5">bitDepth</link>);
881 &#32;&#32;&#32;&#32;
882 &#32;&#32;&#32;&#32;<emphasis role="keywordflow">if</emphasis>&#32;(audioFormat&#32;==&#32;<link linkend="__audio_file_8h_1a24ed57f869bfefdef1bed0a033886d8eaf48e2c55df672bab9d55c60af50a7181">WavAudioFormat::IEEEFloat</link>)
883 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;addInt16ToFileData&#32;(fileData,&#32;0);&#32;<emphasis role="comment">//&#32;extension&#32;size</emphasis>
884 &#32;&#32;&#32;&#32;
885 &#32;&#32;&#32;&#32;<emphasis role="comment">//&#32;-----------------------------------------------------------</emphasis>
886 &#32;&#32;&#32;&#32;<emphasis role="comment">//&#32;DATA&#32;CHUNK</emphasis>
887 &#32;&#32;&#32;&#32;addStringToFileData&#32;(fileData,&#32;<emphasis role="stringliteral">&quot;data&quot;</emphasis>);
888 &#32;&#32;&#32;&#32;addInt32ToFileData&#32;(fileData,&#32;dataChunkSize);
889 &#32;&#32;&#32;&#32;
890 &#32;&#32;&#32;&#32;<emphasis role="keywordflow">for</emphasis>&#32;(<emphasis role="keywordtype">int</emphasis>&#32;i&#32;=&#32;0;&#32;i&#32;&lt;&#32;getNumSamplesPerChannel();&#32;i++)
891 &#32;&#32;&#32;&#32;{
892 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keywordflow">for</emphasis>&#32;(<emphasis role="keywordtype">int</emphasis>&#32;channel&#32;=&#32;0;&#32;channel&#32;&lt;&#32;getNumChannels();&#32;channel++)
893 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;{
894 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keywordflow">if</emphasis>&#32;(<link linkend="_namespaceaiff__stereo__16bit__44100_1a9437286c09cbbda5f152c5a5e231eda5">bitDepth</link>&#32;==&#32;8)
895 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;{
896 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;uint8_t&#32;<emphasis role="keywordtype">byte</emphasis>&#32;=&#32;sampleToSingleByte&#32;(samples[channel][i]);
897 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;fileData.push_back&#32;(<emphasis role="keywordtype">byte</emphasis>);
898 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;}
899 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keywordflow">else</emphasis>&#32;<emphasis role="keywordflow">if</emphasis>&#32;(<link linkend="_namespaceaiff__stereo__16bit__44100_1a9437286c09cbbda5f152c5a5e231eda5">bitDepth</link>&#32;==&#32;16)
900 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;{
901 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;int16_t&#32;sampleAsInt&#32;=&#32;sampleToSixteenBitInt&#32;(samples[channel][i]);
902 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;addInt16ToFileData&#32;(fileData,&#32;sampleAsInt);
903 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;}
904 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keywordflow">else</emphasis>&#32;<emphasis role="keywordflow">if</emphasis>&#32;(<link linkend="_namespaceaiff__stereo__16bit__44100_1a9437286c09cbbda5f152c5a5e231eda5">bitDepth</link>&#32;==&#32;24)
905 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;{
906 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;int32_t&#32;sampleAsIntAgain&#32;=&#32;(int32_t)&#32;(samples[channel][i]&#32;*&#32;(T)8388608.);
907 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;
908 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;uint8_t&#32;bytes[3];
909 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;bytes[2]&#32;=&#32;(uint8_t)&#32;(sampleAsIntAgain&#32;&gt;&gt;&#32;16)&#32;&amp;&#32;0xFF;
910 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;bytes[1]&#32;=&#32;(uint8_t)&#32;(sampleAsIntAgain&#32;&gt;&gt;&#32;&#32;8)&#32;&amp;&#32;0xFF;
911 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;bytes[0]&#32;=&#32;(uint8_t)&#32;sampleAsIntAgain&#32;&amp;&#32;0xFF;
912 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;
913 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;fileData.push_back&#32;(bytes[0]);
914 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;fileData.push_back&#32;(bytes[1]);
915 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;fileData.push_back&#32;(bytes[2]);
916 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;}
917 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keywordflow">else</emphasis>&#32;<emphasis role="keywordflow">if</emphasis>&#32;(<link linkend="_namespaceaiff__stereo__16bit__44100_1a9437286c09cbbda5f152c5a5e231eda5">bitDepth</link>&#32;==&#32;32)
918 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;{
919 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;int32_t&#32;sampleAsInt;
920 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;
921 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keywordflow">if</emphasis>&#32;(audioFormat&#32;==&#32;<link linkend="__audio_file_8h_1a24ed57f869bfefdef1bed0a033886d8eaf48e2c55df672bab9d55c60af50a7181">WavAudioFormat::IEEEFloat</link>)
922 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;sampleAsInt&#32;=&#32;(int32_t)&#32;<emphasis role="keyword">reinterpret_cast&lt;</emphasis>int32_t&amp;<emphasis role="keyword">&gt;</emphasis>&#32;(samples[channel][i]);
923 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keywordflow">else</emphasis>&#32;<emphasis role="comment">//&#32;assume&#32;PCM</emphasis>
924 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;sampleAsInt&#32;=&#32;(int32_t)&#32;(samples[channel][i]&#32;*&#32;std::numeric_limits&lt;int32_t&gt;::max());
925 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;
926 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;addInt32ToFileData&#32;(fileData,&#32;sampleAsInt,&#32;Endianness::LittleEndian);
927 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;}
928 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keywordflow">else</emphasis>
929 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;{
930 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;assert&#32;(<emphasis role="keyword">false</emphasis>&#32;&amp;&amp;&#32;<emphasis role="stringliteral">&quot;Trying&#32;to&#32;write&#32;a&#32;file&#32;with&#32;unsupported&#32;bit&#32;depth&quot;</emphasis>);
931 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keywordflow">return</emphasis>&#32;<emphasis role="keyword">false</emphasis>;
932 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;}
933 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;}
934 &#32;&#32;&#32;&#32;}
935 &#32;&#32;&#32;&#32;
936 &#32;&#32;&#32;&#32;<emphasis role="comment">//&#32;-----------------------------------------------------------</emphasis>
937 &#32;&#32;&#32;&#32;<emphasis role="comment">//&#32;iXML&#32;CHUNK</emphasis>
938 &#32;&#32;&#32;&#32;<emphasis role="keywordflow">if</emphasis>&#32;(iXMLChunkSize&#32;&gt;&#32;0)&#32;
939 &#32;&#32;&#32;&#32;{
940 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;addStringToFileData&#32;(fileData,&#32;<emphasis role="stringliteral">&quot;iXML&quot;</emphasis>);
941 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;addInt32ToFileData&#32;(fileData,&#32;iXMLChunkSize);
942 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;addStringToFileData&#32;(fileData,&#32;iXMLChunk);
943 &#32;&#32;&#32;&#32;}
944 &#32;&#32;&#32;&#32;
945 &#32;&#32;&#32;&#32;<emphasis role="comment">//&#32;check&#32;that&#32;the&#32;various&#32;sizes&#32;we&#32;put&#32;in&#32;the&#32;metadata&#32;are&#32;correct</emphasis>
946 &#32;&#32;&#32;&#32;<emphasis role="keywordflow">if</emphasis>&#32;(fileSizeInBytes&#32;!=&#32;<emphasis role="keyword">static_cast&lt;</emphasis>int32_t<emphasis role="keyword">&gt;</emphasis>&#32;(fileData.size()&#32;-&#32;8)&#32;||&#32;dataChunkSize&#32;!=&#32;(getNumSamplesPerChannel()&#32;*&#32;getNumChannels()&#32;*&#32;(<link linkend="_namespaceaiff__stereo__16bit__44100_1a9437286c09cbbda5f152c5a5e231eda5">bitDepth</link>&#32;/&#32;8)))
947 &#32;&#32;&#32;&#32;{
948 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;reportError&#32;(<emphasis role="stringliteral">&quot;ERROR:&#32;couldn&apos;t&#32;save&#32;file&#32;to&#32;&quot;</emphasis>&#32;+&#32;filePath);
949 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keywordflow">return</emphasis>&#32;<emphasis role="keyword">false</emphasis>;
950 &#32;&#32;&#32;&#32;}
951 &#32;&#32;&#32;&#32;
952 &#32;&#32;&#32;&#32;<emphasis role="comment">//&#32;try&#32;to&#32;write&#32;the&#32;file</emphasis>
953 &#32;&#32;&#32;&#32;<emphasis role="keywordflow">return</emphasis>&#32;writeDataToFile&#32;(fileData,&#32;filePath);
954 }
955 
956 <emphasis role="comment">//=============================================================</emphasis>
957 <emphasis role="keyword">template</emphasis>&#32;&lt;<emphasis role="keyword">class</emphasis>&#32;T&gt;
958 <emphasis role="keywordtype">bool</emphasis>&#32;<link linkend="_class_audio_file">AudioFile&lt;T&gt;::saveToAiffFile</link>&#32;(std::string&#32;filePath)
959 {
960 &#32;&#32;&#32;&#32;std::vector&lt;uint8_t&gt;&#32;fileData;
961 &#32;&#32;&#32;&#32;
962 &#32;&#32;&#32;&#32;int32_t&#32;numBytesPerSample&#32;=&#32;<link linkend="_namespaceaiff__stereo__16bit__44100_1a9437286c09cbbda5f152c5a5e231eda5">bitDepth</link>&#32;/&#32;8;
963 &#32;&#32;&#32;&#32;int32_t&#32;numBytesPerFrame&#32;=&#32;numBytesPerSample&#32;*&#32;getNumChannels();
964 &#32;&#32;&#32;&#32;int32_t&#32;totalNumAudioSampleBytes&#32;=&#32;getNumSamplesPerChannel()&#32;*&#32;numBytesPerFrame;
965 &#32;&#32;&#32;&#32;int32_t&#32;soundDataChunkSize&#32;=&#32;totalNumAudioSampleBytes&#32;+&#32;8;
966 &#32;&#32;&#32;&#32;int32_t&#32;iXMLChunkSize&#32;=&#32;<emphasis role="keyword">static_cast&lt;</emphasis>int32_t<emphasis role="keyword">&gt;</emphasis>&#32;(iXMLChunk.size());
967 &#32;&#32;&#32;&#32;
968 &#32;&#32;&#32;&#32;<emphasis role="comment">//&#32;-----------------------------------------------------------</emphasis>
969 &#32;&#32;&#32;&#32;<emphasis role="comment">//&#32;HEADER&#32;CHUNK</emphasis>
970 &#32;&#32;&#32;&#32;addStringToFileData&#32;(fileData,&#32;<emphasis role="stringliteral">&quot;FORM&quot;</emphasis>);
971 &#32;&#32;&#32;&#32;
972 &#32;&#32;&#32;&#32;<emphasis role="comment">//&#32;The&#32;file&#32;size&#32;in&#32;bytes&#32;is&#32;the&#32;header&#32;chunk&#32;size&#32;(4,&#32;not&#32;counting&#32;FORM&#32;and&#32;AIFF)&#32;+&#32;the&#32;COMM</emphasis>
973 &#32;&#32;&#32;&#32;<emphasis role="comment">//&#32;chunk&#32;size&#32;(26)&#32;+&#32;the&#32;metadata&#32;part&#32;of&#32;the&#32;SSND&#32;chunk&#32;plus&#32;the&#32;actual&#32;data&#32;chunk&#32;size</emphasis>
974 &#32;&#32;&#32;&#32;int32_t&#32;fileSizeInBytes&#32;=&#32;4&#32;+&#32;26&#32;+&#32;16&#32;+&#32;totalNumAudioSampleBytes;
975 &#32;&#32;&#32;&#32;<emphasis role="keywordflow">if</emphasis>&#32;(iXMLChunkSize&#32;&gt;&#32;0)
976 &#32;&#32;&#32;&#32;{
977 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;fileSizeInBytes&#32;+=&#32;(8&#32;+&#32;iXMLChunkSize);
978 &#32;&#32;&#32;&#32;}
979 
980 &#32;&#32;&#32;&#32;addInt32ToFileData&#32;(fileData,&#32;fileSizeInBytes,&#32;Endianness::BigEndian);
981 &#32;&#32;&#32;&#32;
982 &#32;&#32;&#32;&#32;addStringToFileData&#32;(fileData,&#32;<emphasis role="stringliteral">&quot;AIFF&quot;</emphasis>);
983 &#32;&#32;&#32;&#32;
984 &#32;&#32;&#32;&#32;<emphasis role="comment">//&#32;-----------------------------------------------------------</emphasis>
985 &#32;&#32;&#32;&#32;<emphasis role="comment">//&#32;COMM&#32;CHUNK</emphasis>
986 &#32;&#32;&#32;&#32;addStringToFileData&#32;(fileData,&#32;<emphasis role="stringliteral">&quot;COMM&quot;</emphasis>);
987 &#32;&#32;&#32;&#32;addInt32ToFileData&#32;(fileData,&#32;18,&#32;Endianness::BigEndian);&#32;<emphasis role="comment">//&#32;commChunkSize</emphasis>
988 &#32;&#32;&#32;&#32;addInt16ToFileData&#32;(fileData,&#32;getNumChannels(),&#32;Endianness::BigEndian);&#32;<emphasis role="comment">//&#32;num&#32;channels</emphasis>
989 &#32;&#32;&#32;&#32;addInt32ToFileData&#32;(fileData,&#32;getNumSamplesPerChannel(),&#32;Endianness::BigEndian);&#32;<emphasis role="comment">//&#32;num&#32;samples&#32;per&#32;channel</emphasis>
990 &#32;&#32;&#32;&#32;addInt16ToFileData&#32;(fileData,&#32;<link linkend="_namespaceaiff__stereo__16bit__44100_1a9437286c09cbbda5f152c5a5e231eda5">bitDepth</link>,&#32;Endianness::BigEndian);&#32;<emphasis role="comment">//&#32;bit&#32;depth</emphasis>
991 &#32;&#32;&#32;&#32;addSampleRateToAiffData&#32;(fileData,&#32;<link linkend="_namespaceaiff__stereo__16bit__44100_1a495b7a67f7fb515c0a5df8139c44e8c4">sampleRate</link>);
992 &#32;&#32;&#32;&#32;
993 &#32;&#32;&#32;&#32;<emphasis role="comment">//&#32;-----------------------------------------------------------</emphasis>
994 &#32;&#32;&#32;&#32;<emphasis role="comment">//&#32;SSND&#32;CHUNK</emphasis>
995 &#32;&#32;&#32;&#32;addStringToFileData&#32;(fileData,&#32;<emphasis role="stringliteral">&quot;SSND&quot;</emphasis>);
996 &#32;&#32;&#32;&#32;addInt32ToFileData&#32;(fileData,&#32;soundDataChunkSize,&#32;Endianness::BigEndian);
997 &#32;&#32;&#32;&#32;addInt32ToFileData&#32;(fileData,&#32;0,&#32;Endianness::BigEndian);&#32;<emphasis role="comment">//&#32;offset</emphasis>
998 &#32;&#32;&#32;&#32;addInt32ToFileData&#32;(fileData,&#32;0,&#32;Endianness::BigEndian);&#32;<emphasis role="comment">//&#32;block&#32;size</emphasis>
999 &#32;&#32;&#32;&#32;
1000 &#32;&#32;&#32;&#32;<emphasis role="keywordflow">for</emphasis>&#32;(<emphasis role="keywordtype">int</emphasis>&#32;i&#32;=&#32;0;&#32;i&#32;&lt;&#32;getNumSamplesPerChannel();&#32;i++)
1001 &#32;&#32;&#32;&#32;{
1002 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keywordflow">for</emphasis>&#32;(<emphasis role="keywordtype">int</emphasis>&#32;channel&#32;=&#32;0;&#32;channel&#32;&lt;&#32;getNumChannels();&#32;channel++)
1003 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;{
1004 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keywordflow">if</emphasis>&#32;(<link linkend="_namespaceaiff__stereo__16bit__44100_1a9437286c09cbbda5f152c5a5e231eda5">bitDepth</link>&#32;==&#32;8)
1005 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;{
1006 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;uint8_t&#32;<emphasis role="keywordtype">byte</emphasis>&#32;=&#32;sampleToSingleByte&#32;(samples[channel][i]);
1007 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;fileData.push_back&#32;(<emphasis role="keywordtype">byte</emphasis>);
1008 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;}
1009 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keywordflow">else</emphasis>&#32;<emphasis role="keywordflow">if</emphasis>&#32;(<link linkend="_namespaceaiff__stereo__16bit__44100_1a9437286c09cbbda5f152c5a5e231eda5">bitDepth</link>&#32;==&#32;16)
1010 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;{
1011 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;int16_t&#32;sampleAsInt&#32;=&#32;sampleToSixteenBitInt&#32;(samples[channel][i]);
1012 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;addInt16ToFileData&#32;(fileData,&#32;sampleAsInt,&#32;Endianness::BigEndian);
1013 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;}
1014 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keywordflow">else</emphasis>&#32;<emphasis role="keywordflow">if</emphasis>&#32;(<link linkend="_namespaceaiff__stereo__16bit__44100_1a9437286c09cbbda5f152c5a5e231eda5">bitDepth</link>&#32;==&#32;24)
1015 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;{
1016 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;int32_t&#32;sampleAsIntAgain&#32;=&#32;(int32_t)&#32;(samples[channel][i]&#32;*&#32;(T)8388608.);
1017 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;
1018 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;uint8_t&#32;bytes[3];
1019 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;bytes[0]&#32;=&#32;(uint8_t)&#32;(sampleAsIntAgain&#32;&gt;&gt;&#32;16)&#32;&amp;&#32;0xFF;
1020 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;bytes[1]&#32;=&#32;(uint8_t)&#32;(sampleAsIntAgain&#32;&gt;&gt;&#32;&#32;8)&#32;&amp;&#32;0xFF;
1021 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;bytes[2]&#32;=&#32;(uint8_t)&#32;sampleAsIntAgain&#32;&amp;&#32;0xFF;
1022 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;
1023 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;fileData.push_back&#32;(bytes[0]);
1024 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;fileData.push_back&#32;(bytes[1]);
1025 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;fileData.push_back&#32;(bytes[2]);
1026 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;}
1027 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keywordflow">else</emphasis>&#32;<emphasis role="keywordflow">if</emphasis>&#32;(<link linkend="_namespaceaiff__stereo__16bit__44100_1a9437286c09cbbda5f152c5a5e231eda5">bitDepth</link>&#32;==&#32;32)
1028 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;{
1029 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="comment">//&#32;write&#32;samples&#32;as&#32;signed&#32;integers&#32;(no&#32;implementation&#32;yet&#32;for&#32;floating&#32;point,&#32;but&#32;looking&#32;at&#32;WAV&#32;implementation&#32;should&#32;help)</emphasis>
1030 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;int32_t&#32;sampleAsInt&#32;=&#32;(int32_t)&#32;(samples[channel][i]&#32;*&#32;std::numeric_limits&lt;int32_t&gt;::max());
1031 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;addInt32ToFileData&#32;(fileData,&#32;sampleAsInt,&#32;Endianness::BigEndian);
1032 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;}
1033 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keywordflow">else</emphasis>
1034 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;{
1035 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;assert&#32;(<emphasis role="keyword">false</emphasis>&#32;&amp;&amp;&#32;<emphasis role="stringliteral">&quot;Trying&#32;to&#32;write&#32;a&#32;file&#32;with&#32;unsupported&#32;bit&#32;depth&quot;</emphasis>);
1036 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keywordflow">return</emphasis>&#32;<emphasis role="keyword">false</emphasis>;
1037 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;}
1038 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;}
1039 &#32;&#32;&#32;&#32;}
1040 
1041 &#32;&#32;&#32;&#32;<emphasis role="comment">//&#32;-----------------------------------------------------------</emphasis>
1042 &#32;&#32;&#32;&#32;<emphasis role="comment">//&#32;iXML&#32;CHUNK</emphasis>
1043 &#32;&#32;&#32;&#32;<emphasis role="keywordflow">if</emphasis>&#32;(iXMLChunkSize&#32;&gt;&#32;0)
1044 &#32;&#32;&#32;&#32;{
1045 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;addStringToFileData&#32;(fileData,&#32;<emphasis role="stringliteral">&quot;iXML&quot;</emphasis>);
1046 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;addInt32ToFileData&#32;(fileData,&#32;iXMLChunkSize,&#32;Endianness::BigEndian);
1047 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;addStringToFileData&#32;(fileData,&#32;iXMLChunk);
1048 &#32;&#32;&#32;&#32;}
1049 &#32;&#32;&#32;&#32;
1050 &#32;&#32;&#32;&#32;<emphasis role="comment">//&#32;check&#32;that&#32;the&#32;various&#32;sizes&#32;we&#32;put&#32;in&#32;the&#32;metadata&#32;are&#32;correct</emphasis>
1051 &#32;&#32;&#32;&#32;<emphasis role="keywordflow">if</emphasis>&#32;(fileSizeInBytes&#32;!=&#32;<emphasis role="keyword">static_cast&lt;</emphasis>int32_t<emphasis role="keyword">&gt;</emphasis>&#32;(fileData.size()&#32;-&#32;8)&#32;||&#32;soundDataChunkSize&#32;!=&#32;getNumSamplesPerChannel()&#32;*&#32;&#32;numBytesPerFrame&#32;+&#32;8)
1052 &#32;&#32;&#32;&#32;{
1053 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;reportError&#32;(<emphasis role="stringliteral">&quot;ERROR:&#32;couldn&apos;t&#32;save&#32;file&#32;to&#32;&quot;</emphasis>&#32;+&#32;filePath);
1054 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keywordflow">return</emphasis>&#32;<emphasis role="keyword">false</emphasis>;
1055 &#32;&#32;&#32;&#32;}
1056 &#32;&#32;&#32;&#32;
1057 &#32;&#32;&#32;&#32;<emphasis role="comment">//&#32;try&#32;to&#32;write&#32;the&#32;file</emphasis>
1058 &#32;&#32;&#32;&#32;<emphasis role="keywordflow">return</emphasis>&#32;writeDataToFile&#32;(fileData,&#32;filePath);
1059 }
1060 
1061 <emphasis role="comment">//=============================================================</emphasis>
1062 <emphasis role="keyword">template</emphasis>&#32;&lt;<emphasis role="keyword">class</emphasis>&#32;T&gt;
1063 <emphasis role="keywordtype">bool</emphasis>&#32;<link linkend="_class_audio_file">AudioFile&lt;T&gt;::writeDataToFile</link>&#32;(std::vector&lt;uint8_t&gt;&amp;&#32;fileData,&#32;std::string&#32;filePath)
1064 {
1065 &#32;&#32;&#32;&#32;std::ofstream&#32;outputFile&#32;(filePath,&#32;std::ios::binary);
1066 &#32;&#32;&#32;&#32;
1067 &#32;&#32;&#32;&#32;<emphasis role="keywordflow">if</emphasis>&#32;(outputFile.is_open())
1068 &#32;&#32;&#32;&#32;{
1069 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keywordflow">for</emphasis>&#32;(<emphasis role="keywordtype">size_t</emphasis>&#32;i&#32;=&#32;0;&#32;i&#32;&lt;&#32;fileData.size();&#32;i++)
1070 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;{
1071 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keywordtype">char</emphasis>&#32;value&#32;=&#32;(char)&#32;fileData[i];
1072 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;outputFile.write&#32;(&amp;value,&#32;<emphasis role="keyword">sizeof</emphasis>&#32;(<emphasis role="keywordtype">char</emphasis>));
1073 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;}
1074 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;
1075 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;outputFile.close();
1076 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;
1077 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keywordflow">return</emphasis>&#32;<emphasis role="keyword">true</emphasis>;
1078 &#32;&#32;&#32;&#32;}
1079 &#32;&#32;&#32;&#32;
1080 &#32;&#32;&#32;&#32;<emphasis role="keywordflow">return</emphasis>&#32;<emphasis role="keyword">false</emphasis>;
1081 }
1082 
1083 <emphasis role="comment">//=============================================================</emphasis>
1084 <emphasis role="keyword">template</emphasis>&#32;&lt;<emphasis role="keyword">class</emphasis>&#32;T&gt;
1085 <emphasis role="keywordtype">void</emphasis>&#32;<link linkend="_class_audio_file">AudioFile&lt;T&gt;::addStringToFileData</link>&#32;(std::vector&lt;uint8_t&gt;&amp;&#32;fileData,&#32;std::string&#32;s)
1086 {
1087 &#32;&#32;&#32;&#32;<emphasis role="keywordflow">for</emphasis>&#32;(<emphasis role="keywordtype">size_t</emphasis>&#32;i&#32;=&#32;0;&#32;i&#32;&lt;&#32;s.length();i++)
1088 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;fileData.push_back&#32;((uint8_t)&#32;s[i]);
1089 }
1090 
1091 <emphasis role="comment">//=============================================================</emphasis>
1092 <emphasis role="keyword">template</emphasis>&#32;&lt;<emphasis role="keyword">class</emphasis>&#32;T&gt;
1093 <emphasis role="keywordtype">void</emphasis>&#32;<link linkend="_class_audio_file">AudioFile&lt;T&gt;::addInt32ToFileData</link>&#32;(std::vector&lt;uint8_t&gt;&amp;&#32;fileData,&#32;int32_t&#32;i,&#32;Endianness&#32;endianness)
1094 {
1095 &#32;&#32;&#32;&#32;uint8_t&#32;bytes[4];
1096 &#32;&#32;&#32;&#32;
1097 &#32;&#32;&#32;&#32;<emphasis role="keywordflow">if</emphasis>&#32;(endianness&#32;==&#32;Endianness::LittleEndian)
1098 &#32;&#32;&#32;&#32;{
1099 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;bytes[3]&#32;=&#32;(i&#32;&gt;&gt;&#32;24)&#32;&amp;&#32;0xFF;
1100 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;bytes[2]&#32;=&#32;(i&#32;&gt;&gt;&#32;16)&#32;&amp;&#32;0xFF;
1101 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;bytes[1]&#32;=&#32;(i&#32;&gt;&gt;&#32;8)&#32;&amp;&#32;0xFF;
1102 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;bytes[0]&#32;=&#32;i&#32;&amp;&#32;0xFF;
1103 &#32;&#32;&#32;&#32;}
1104 &#32;&#32;&#32;&#32;<emphasis role="keywordflow">else</emphasis>
1105 &#32;&#32;&#32;&#32;{
1106 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;bytes[0]&#32;=&#32;(i&#32;&gt;&gt;&#32;24)&#32;&amp;&#32;0xFF;
1107 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;bytes[1]&#32;=&#32;(i&#32;&gt;&gt;&#32;16)&#32;&amp;&#32;0xFF;
1108 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;bytes[2]&#32;=&#32;(i&#32;&gt;&gt;&#32;8)&#32;&amp;&#32;0xFF;
1109 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;bytes[3]&#32;=&#32;i&#32;&amp;&#32;0xFF;
1110 &#32;&#32;&#32;&#32;}
1111 &#32;&#32;&#32;&#32;
1112 &#32;&#32;&#32;&#32;<emphasis role="keywordflow">for</emphasis>&#32;(<emphasis role="keywordtype">int</emphasis>&#32;i&#32;=&#32;0;&#32;i&#32;&lt;&#32;4;&#32;i++)
1113 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;fileData.push_back&#32;(bytes[i]);
1114 }
1115 
1116 <emphasis role="comment">//=============================================================</emphasis>
1117 <emphasis role="keyword">template</emphasis>&#32;&lt;<emphasis role="keyword">class</emphasis>&#32;T&gt;
1118 <emphasis role="keywordtype">void</emphasis>&#32;<link linkend="_class_audio_file">AudioFile&lt;T&gt;::addInt16ToFileData</link>&#32;(std::vector&lt;uint8_t&gt;&amp;&#32;fileData,&#32;int16_t&#32;i,&#32;Endianness&#32;endianness)
1119 {
1120 &#32;&#32;&#32;&#32;uint8_t&#32;bytes[2];
1121 &#32;&#32;&#32;&#32;
1122 &#32;&#32;&#32;&#32;<emphasis role="keywordflow">if</emphasis>&#32;(endianness&#32;==&#32;Endianness::LittleEndian)
1123 &#32;&#32;&#32;&#32;{
1124 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;bytes[1]&#32;=&#32;(i&#32;&gt;&gt;&#32;8)&#32;&amp;&#32;0xFF;
1125 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;bytes[0]&#32;=&#32;i&#32;&amp;&#32;0xFF;
1126 &#32;&#32;&#32;&#32;}
1127 &#32;&#32;&#32;&#32;<emphasis role="keywordflow">else</emphasis>
1128 &#32;&#32;&#32;&#32;{
1129 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;bytes[0]&#32;=&#32;(i&#32;&gt;&gt;&#32;8)&#32;&amp;&#32;0xFF;
1130 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;bytes[1]&#32;=&#32;i&#32;&amp;&#32;0xFF;
1131 &#32;&#32;&#32;&#32;}
1132 &#32;&#32;&#32;&#32;
1133 &#32;&#32;&#32;&#32;fileData.push_back&#32;(bytes[0]);
1134 &#32;&#32;&#32;&#32;fileData.push_back&#32;(bytes[1]);
1135 }
1136 
1137 <emphasis role="comment">//=============================================================</emphasis>
1138 <emphasis role="keyword">template</emphasis>&#32;&lt;<emphasis role="keyword">class</emphasis>&#32;T&gt;
1139 <emphasis role="keywordtype">void</emphasis>&#32;<link linkend="_class_audio_file">AudioFile&lt;T&gt;::clearAudioBuffer</link>()
1140 {
1141 &#32;&#32;&#32;&#32;<emphasis role="keywordflow">for</emphasis>&#32;(<emphasis role="keywordtype">size_t</emphasis>&#32;i&#32;=&#32;0;&#32;i&#32;&lt;&#32;samples.size();i++)
1142 &#32;&#32;&#32;&#32;{
1143 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;samples[i].clear();
1144 &#32;&#32;&#32;&#32;}
1145 &#32;&#32;&#32;&#32;
1146 &#32;&#32;&#32;&#32;samples.clear();
1147 }
1148 
1149 <emphasis role="comment">//=============================================================</emphasis>
1150 <emphasis role="keyword">template</emphasis>&#32;&lt;<emphasis role="keyword">class</emphasis>&#32;T&gt;
1151 <link linkend="__audio_file_8h_1ad18559d169602e85d0ad68da6ef8593f">AudioFileFormat</link>&#32;<link linkend="_class_audio_file">AudioFile&lt;T&gt;::determineAudioFileFormat</link>&#32;(std::vector&lt;uint8_t&gt;&amp;&#32;fileData)
1152 {
1153 &#32;&#32;&#32;&#32;std::string&#32;header&#32;(fileData.begin(),&#32;fileData.begin()&#32;+&#32;4);
1154 &#32;&#32;&#32;&#32;
1155 &#32;&#32;&#32;&#32;<emphasis role="keywordflow">if</emphasis>&#32;(header&#32;==&#32;<emphasis role="stringliteral">&quot;RIFF&quot;</emphasis>)
1156 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keywordflow">return</emphasis>&#32;<link linkend="__audio_file_8h_1ad18559d169602e85d0ad68da6ef8593fad911b34823c7674c292556dc56148c27">AudioFileFormat::Wave</link>;
1157 &#32;&#32;&#32;&#32;<emphasis role="keywordflow">else</emphasis>&#32;<emphasis role="keywordflow">if</emphasis>&#32;(header&#32;==&#32;<emphasis role="stringliteral">&quot;FORM&quot;</emphasis>)
1158 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keywordflow">return</emphasis>&#32;<link linkend="__audio_file_8h_1ad18559d169602e85d0ad68da6ef8593fac2271ab764905d770a81d0920f8c6aaf">AudioFileFormat::Aiff</link>;
1159 &#32;&#32;&#32;&#32;<emphasis role="keywordflow">else</emphasis>
1160 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keywordflow">return</emphasis>&#32;<link linkend="__audio_file_8h_1a526ed66f20752002a63ee72e2e350d7da4dfd42ec49d09d8c6555c218301cc30f">AudioFileFormat::Error</link>;
1161 }
1162 
1163 <emphasis role="comment">//=============================================================</emphasis>
1164 <emphasis role="keyword">template</emphasis>&#32;&lt;<emphasis role="keyword">class</emphasis>&#32;T&gt;
1165 int32_t&#32;<link linkend="_class_audio_file">AudioFile&lt;T&gt;::fourBytesToInt</link>&#32;(std::vector&lt;uint8_t&gt;&amp;&#32;source,&#32;<emphasis role="keywordtype">int</emphasis>&#32;startIndex,&#32;Endianness&#32;endianness)
1166 {
1167 &#32;&#32;&#32;&#32;int32_t&#32;result;
1168 &#32;&#32;&#32;&#32;
1169 &#32;&#32;&#32;&#32;<emphasis role="keywordflow">if</emphasis>&#32;(endianness&#32;==&#32;Endianness::LittleEndian)
1170 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;result&#32;=&#32;(source[startIndex&#32;+&#32;3]&#32;&lt;&lt;&#32;24)&#32;|&#32;(source[startIndex&#32;+&#32;2]&#32;&lt;&lt;&#32;16)&#32;|&#32;(source[startIndex&#32;+&#32;1]&#32;&lt;&lt;&#32;8)&#32;|&#32;source[startIndex];
1171 &#32;&#32;&#32;&#32;<emphasis role="keywordflow">else</emphasis>
1172 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;result&#32;=&#32;(source[startIndex]&#32;&lt;&lt;&#32;24)&#32;|&#32;(source[startIndex&#32;+&#32;1]&#32;&lt;&lt;&#32;16)&#32;|&#32;(source[startIndex&#32;+&#32;2]&#32;&lt;&lt;&#32;8)&#32;|&#32;source[startIndex&#32;+&#32;3];
1173 &#32;&#32;&#32;&#32;
1174 &#32;&#32;&#32;&#32;<emphasis role="keywordflow">return</emphasis>&#32;result;
1175 }
1176 
1177 <emphasis role="comment">//=============================================================</emphasis>
1178 <emphasis role="keyword">template</emphasis>&#32;&lt;<emphasis role="keyword">class</emphasis>&#32;T&gt;
1179 int16_t&#32;<link linkend="_class_audio_file">AudioFile&lt;T&gt;::twoBytesToInt</link>&#32;(std::vector&lt;uint8_t&gt;&amp;&#32;source,&#32;<emphasis role="keywordtype">int</emphasis>&#32;startIndex,&#32;Endianness&#32;endianness)
1180 {
1181 &#32;&#32;&#32;&#32;int16_t&#32;result;
1182 &#32;&#32;&#32;&#32;
1183 &#32;&#32;&#32;&#32;<emphasis role="keywordflow">if</emphasis>&#32;(endianness&#32;==&#32;Endianness::LittleEndian)
1184 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;result&#32;=&#32;(source[startIndex&#32;+&#32;1]&#32;&lt;&lt;&#32;8)&#32;|&#32;source[startIndex];
1185 &#32;&#32;&#32;&#32;<emphasis role="keywordflow">else</emphasis>
1186 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;result&#32;=&#32;(source[startIndex]&#32;&lt;&lt;&#32;8)&#32;|&#32;source[startIndex&#32;+&#32;1];
1187 &#32;&#32;&#32;&#32;
1188 &#32;&#32;&#32;&#32;<emphasis role="keywordflow">return</emphasis>&#32;result;
1189 }
1190 
1191 <emphasis role="comment">//=============================================================</emphasis>
1192 <emphasis role="keyword">template</emphasis>&#32;&lt;<emphasis role="keyword">class</emphasis>&#32;T&gt;
1193 <emphasis role="keywordtype">int</emphasis>&#32;<link linkend="_class_audio_file">AudioFile&lt;T&gt;::getIndexOfString</link>&#32;(std::vector&lt;uint8_t&gt;&amp;&#32;source,&#32;std::string&#32;stringToSearchFor)
1194 {
1195 &#32;&#32;&#32;&#32;<emphasis role="keywordtype">int</emphasis>&#32;index&#32;=&#32;-1;
1196 &#32;&#32;&#32;&#32;<emphasis role="keywordtype">int</emphasis>&#32;stringLength&#32;=&#32;(int)stringToSearchFor.length();
1197 &#32;&#32;&#32;&#32;
1198 &#32;&#32;&#32;&#32;<emphasis role="keywordflow">for</emphasis>&#32;(<emphasis role="keywordtype">size_t</emphasis>&#32;i&#32;=&#32;0;&#32;i&#32;&lt;&#32;source.size()&#32;-&#32;stringLength;i++)
1199 &#32;&#32;&#32;&#32;{
1200 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;std::string&#32;section&#32;(source.begin()&#32;+&#32;i,&#32;source.begin()&#32;+&#32;i&#32;+&#32;stringLength);
1201 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;
1202 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keywordflow">if</emphasis>&#32;(section&#32;==&#32;stringToSearchFor)
1203 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;{
1204 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;index&#32;=&#32;<emphasis role="keyword">static_cast&lt;</emphasis><emphasis role="keywordtype">int</emphasis><emphasis role="keyword">&gt;</emphasis>&#32;(i);
1205 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keywordflow">break</emphasis>;
1206 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;}
1207 &#32;&#32;&#32;&#32;}
1208 &#32;&#32;&#32;&#32;
1209 &#32;&#32;&#32;&#32;<emphasis role="keywordflow">return</emphasis>&#32;index;
1210 }
1211 
1212 <emphasis role="comment">//=============================================================</emphasis>
1213 <emphasis role="keyword">template</emphasis>&#32;&lt;<emphasis role="keyword">class</emphasis>&#32;T&gt;
1214 <emphasis role="keywordtype">int</emphasis>&#32;<link linkend="_class_audio_file">AudioFile&lt;T&gt;::getIndexOfChunk</link>&#32;(std::vector&lt;uint8_t&gt;&amp;&#32;source,&#32;<emphasis role="keyword">const</emphasis>&#32;std::string&amp;&#32;chunkHeaderID,&#32;<emphasis role="keywordtype">int</emphasis>&#32;startIndex,&#32;Endianness&#32;endianness)
1215 {
1216 &#32;&#32;&#32;&#32;<emphasis role="keyword">constexpr</emphasis>&#32;<emphasis role="keywordtype">int</emphasis>&#32;dataLen&#32;=&#32;4;
1217 &#32;&#32;&#32;&#32;<emphasis role="keywordflow">if</emphasis>&#32;(chunkHeaderID.size()&#32;!=&#32;dataLen)
1218 &#32;&#32;&#32;&#32;{
1219 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;assert&#32;(<emphasis role="keyword">false</emphasis>&#32;&amp;&amp;&#32;<emphasis role="stringliteral">&quot;Invalid&#32;chunk&#32;header&#32;ID&#32;string&quot;</emphasis>);
1220 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keywordflow">return</emphasis>&#32;-1;
1221 &#32;&#32;&#32;&#32;}
1222 
1223 &#32;&#32;&#32;&#32;<emphasis role="keywordtype">int</emphasis>&#32;i&#32;=&#32;startIndex;
1224 &#32;&#32;&#32;&#32;<emphasis role="keywordflow">while</emphasis>&#32;(i&#32;&lt;&#32;source.size()&#32;-&#32;dataLen)
1225 &#32;&#32;&#32;&#32;{
1226 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keywordflow">if</emphasis>&#32;(memcmp&#32;(&amp;source[i],&#32;chunkHeaderID.data(),&#32;dataLen)&#32;==&#32;0)
1227 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;{
1228 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keywordflow">return</emphasis>&#32;i;
1229 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;}
1230 
1231 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;i&#32;+=&#32;dataLen;
1232 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;<emphasis role="keyword">auto</emphasis>&#32;chunkSize&#32;=&#32;fourBytesToInt&#32;(source,&#32;i,&#32;endianness);
1233 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;i&#32;+=&#32;(dataLen&#32;+&#32;chunkSize);
1234 &#32;&#32;&#32;&#32;}
1235 
1236 &#32;&#32;&#32;&#32;<emphasis role="keywordflow">return</emphasis>&#32;-1;
1237 }
1238 
1239 <emphasis role="comment">//=============================================================</emphasis>
1240 <emphasis role="keyword">template</emphasis>&#32;&lt;<emphasis role="keyword">class</emphasis>&#32;T&gt;
1241 T&#32;<link linkend="_class_audio_file">AudioFile&lt;T&gt;::sixteenBitIntToSample</link>&#32;(int16_t&#32;sample)
1242 {
1243 &#32;&#32;&#32;&#32;<emphasis role="keywordflow">return</emphasis>&#32;<emphasis role="keyword">static_cast&lt;</emphasis>T<emphasis role="keyword">&gt;</emphasis>&#32;(sample)&#32;/&#32;<emphasis role="keyword">static_cast&lt;</emphasis>T<emphasis role="keyword">&gt;</emphasis>&#32;(32768.);
1244 }
1245 
1246 <emphasis role="comment">//=============================================================</emphasis>
1247 <emphasis role="keyword">template</emphasis>&#32;&lt;<emphasis role="keyword">class</emphasis>&#32;T&gt;
1248 int16_t&#32;<link linkend="_class_audio_file">AudioFile&lt;T&gt;::sampleToSixteenBitInt</link>&#32;(T&#32;sample)
1249 {
1250 &#32;&#32;&#32;&#32;sample&#32;=&#32;clamp&#32;(sample,&#32;-1.,&#32;1.);
1251 &#32;&#32;&#32;&#32;<emphasis role="keywordflow">return</emphasis>&#32;<emphasis role="keyword">static_cast&lt;</emphasis>int16_t<emphasis role="keyword">&gt;</emphasis>&#32;(sample&#32;*&#32;32767.);
1252 }
1253 
1254 <emphasis role="comment">//=============================================================</emphasis>
1255 <emphasis role="keyword">template</emphasis>&#32;&lt;<emphasis role="keyword">class</emphasis>&#32;T&gt;
1256 uint8_t&#32;<link linkend="_class_audio_file">AudioFile&lt;T&gt;::sampleToSingleByte</link>&#32;(T&#32;sample)
1257 {
1258 &#32;&#32;&#32;&#32;sample&#32;=&#32;clamp&#32;(sample,&#32;-1.,&#32;1.);
1259 &#32;&#32;&#32;&#32;sample&#32;=&#32;(sample&#32;+&#32;1.)&#32;/&#32;2.;
1260 &#32;&#32;&#32;&#32;<emphasis role="keywordflow">return</emphasis>&#32;<emphasis role="keyword">static_cast&lt;</emphasis>uint8_t<emphasis role="keyword">&gt;</emphasis>&#32;(sample&#32;*&#32;255.);
1261 }
1262 
1263 <emphasis role="comment">//=============================================================</emphasis>
1264 <emphasis role="keyword">template</emphasis>&#32;&lt;<emphasis role="keyword">class</emphasis>&#32;T&gt;
1265 T&#32;<link linkend="_class_audio_file">AudioFile&lt;T&gt;::singleByteToSample</link>&#32;(uint8_t&#32;sample)
1266 {
1267 &#32;&#32;&#32;&#32;<emphasis role="keywordflow">return</emphasis>&#32;<emphasis role="keyword">static_cast&lt;</emphasis>T<emphasis role="keyword">&gt;</emphasis>&#32;(sample&#32;-&#32;128)&#32;/&#32;<emphasis role="keyword">static_cast&lt;</emphasis>T<emphasis role="keyword">&gt;</emphasis>&#32;(128.);
1268 }
1269 
1270 <emphasis role="comment">//=============================================================</emphasis>
1271 <emphasis role="keyword">template</emphasis>&#32;&lt;<emphasis role="keyword">class</emphasis>&#32;T&gt;
1272 T&#32;<link linkend="_class_audio_file">AudioFile&lt;T&gt;::clamp</link>&#32;(T&#32;value,&#32;T&#32;minValue,&#32;T&#32;maxValue)
1273 {
1274 &#32;&#32;&#32;&#32;value&#32;=&#32;std::min&#32;(value,&#32;maxValue);
1275 &#32;&#32;&#32;&#32;value&#32;=&#32;std::max&#32;(value,&#32;minValue);
1276 &#32;&#32;&#32;&#32;<emphasis role="keywordflow">return</emphasis>&#32;value;
1277 }
1278 
1279 <emphasis role="comment">//=============================================================</emphasis>
1280 <emphasis role="keyword">template</emphasis>&#32;&lt;<emphasis role="keyword">class</emphasis>&#32;T&gt;
1281 <emphasis role="keywordtype">void</emphasis>&#32;<link linkend="_class_audio_file">AudioFile&lt;T&gt;::reportError</link>&#32;(std::string&#32;errorMessage)
1282 {
1283 &#32;&#32;&#32;&#32;<emphasis role="keywordflow">if</emphasis>&#32;(logErrorsToConsole)
1284 &#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;std::cout&#32;&lt;&lt;&#32;errorMessage&#32;&lt;&lt;&#32;std::endl;
1285 }
1286 
1287 <emphasis role="preprocessor">#if&#32;defined&#32;(_MSC_VER)</emphasis>
1288 &#32;&#32;&#32;&#32;__pragma(warning&#32;(pop))
1289 <emphasis role="preprocessor">#elif&#32;defined&#32;(__GNUC__)</emphasis>
1290 &#32;&#32;&#32;&#32;_Pragma(<emphasis role="stringliteral">&quot;GCC&#32;diagnostic&#32;pop&quot;</emphasis>)
1291 <emphasis role="preprocessor">#endif</emphasis>
1292 
1293 <emphasis role="preprocessor">#endif&#32;</emphasis><emphasis role="comment">/*&#32;AudioFile_h&#32;*/</emphasis><emphasis role="preprocessor"></emphasis>
</programlisting></section>
